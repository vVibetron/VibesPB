/**
 * @OnlyCurrentDoc
 * This script provides comprehensive automation for the SP tracking sheet.
 *
 * FEATURES:
 * 1.  Dynamic Row Coloring: Row background and font color change based on status in Column L.
 * 2.  Automatic Row Insertion: A new row is added at the top when data is entered into row 2.
 * 3.  28-Day Countdown: Automatically calculates 'Days Remaining' in Column D for any new entry (typed or pasted).
 * 4.  Self-Installing Priority Flags: A daily trigger is automatically created to flag SPs needing a welcome call. No manual setup required.
 * 5.  Data Cleanup: Automatically trims whitespace and standardizes cell formatting on every edit.
 * 6.  WC Timestamps: Automatically adds/removes a 'Welcome Call Date' in Column N when status changes.
 * 7.  Automated Follow-Up Dates: Automatically sets a 7-day and 22-day follow-up date in Column J based on WC completion.
 */

// --- CONFIGURATION ---
const AFFECTED_SHEETS = ["Sheet1"]; // <-- IMPORTANT: Change to your exact sheet name if different.

// Column Assignments (A=1, B=2, etc.)
const APPROVAL_DATE_COL = 3; // Column C
const DAYS_REMAINING_COL = 4; // Column D
const FOLLOW_UP_COL = 10; // Column J
const STATUS_COL = 12; // Column L
const PRIORITY_COL = 13; // Column M
const WC_DATE_COL = 14; // Column N

// Row Insertion Settings
const TARGET_ROW_FOR_INSERTION = 2;
const NEW_ROW_DEFAULT_STATUS = "Not called";

/**
 * Runs when the spreadsheet is opened.
 * This function now also automatically creates the daily trigger for priority flags if it doesn't already exist.
 */
function onOpen() {
  // This function will create the daily trigger for you automatically.
  createTimeDrivenTriggers_();
}

/**
 * The main function that runs automatically whenever a user edits the sheet.
 * This function acts as a controller, directing actions based on the edited cell.
 * @param {Object} e The event object from the onEdit trigger.
 */
function onEdit(e) {
  if (!e || !e.range) {
    console.error("onEdit event object is missing crucial data.");
    return;
  }

  const range = e.range;
  const sheet = range.getSheet();
  const sheetName = sheet.getName();

  // Exit if the edited sheet is not in our list of affected sheets.
  if (AFFECTED_SHEETS.indexOf(sheetName) === -1) {
    return;
  }

  const startRow = range.getRow();
  const endRow = range.getLastRow();
  const startCol = range.getColumn();
  const endCol = range.getLastColumn();

  // --- Action 1: Universal Formatting & Cleanup on EVERY edit ---
  try {
    range
      .trimWhitespace()
      .setWrapStrategy(SpreadsheetApp.WrapStrategy.CLIP)
      .setVerticalAlignment("middle")
      .setHorizontalAlignment("left");
  } catch (formatError) {
    console.error(`Could not apply universal formatting: ${formatError.message}`);
  }

  // --- Action 2: Automatic Row Insertion ---
  if (startRow === TARGET_ROW_FOR_INSERTION && range.getDisplayValue().trim() !== "") {
    // A check to prevent the script from re-triggering itself on the insert
    if (e.source.getTriggerUid && e.source.getTriggerUid()) {
        return;
    }
    insertNewRow_(sheet);
  }

  // --- Action 3: Conditional Logic ---

  // A. Handle Countdown Clock (for single or multi-cell edits/pastes)
  // Checks if the edited range includes the Approval Date column.
  if (startCol <= APPROVAL_DATE_COL && endCol >= APPROVAL_DATE_COL) {
    for (let i = startRow; i <= endRow; i++) {
      updateDaysRemaining_(sheet, i);
    }
  }

  // B. Handle Status Change (for single-cell edits)
  // This logic is kept specific to prevent accidental changes during a bulk paste.
  if (startCol === STATUS_COL && endCol === STATUS_COL && startRow === endRow) {
    const statusValue = e.value || "";
    const oldValue = e.oldValue || "";
    applyRowFormatting_(sheet.getRange(startRow, 1, 1, sheet.getMaxColumns()), statusValue);
    updateWelcomeCallTimestamp_(sheet, startRow, statusValue, oldValue);
    manageFirstFollowUpDate_(sheet, startRow, statusValue, oldValue);
  }

  // C. Handle Follow-up Date Deletion (for single-cell edits)
  if (startCol === FOLLOW_UP_COL && endCol === FOLLOW_UP_COL && startRow === endRow) {
    if ((e.value || "") === "") {
      manageSecondFollowUpDate_(sheet, startRow);
    }
  }
}


/**
 * Checks if a daily trigger for the setPriorityFlags function exists, and creates one if it doesn't.
 * This makes the setup fully automatic for the user.
 */
function createTimeDrivenTriggers_() {
  const functionName = 'setPriorityFlags';
  const triggers = ScriptApp.getProjectTriggers();
  let triggerExists = false;

  for (const trigger of triggers) {
    if (trigger.getHandlerFunction() === functionName) {
      triggerExists = true;
      break;
    }
  }

  if (!triggerExists) {
    ScriptApp.newTrigger(functionName)
      .timeBased()
      .everyDays(1)
      .atHour(8) // Runs every day around 8 AM
      .create();
  }
}


/**
 * This function runs automatically every morning to set priority flags.
 */
function setPriorityFlags() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(AFFECTED_SHEETS[0]);
  if (!sheet) return;

  const dataRange = sheet.getDataRange();
  const values = dataRange.getValues();
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  for (let i = 1; i < values.length; i++) {
    const row = i + 1;
    const status = values[i][STATUS_COL - 1];
    const approvalDate = new Date(values[i][APPROVAL_DATE_COL - 1]);

    if (status === "Not called" && approvalDate.valueOf()) {
      const threeDaysAgo = new Date(today);
      threeDaysAgo.setDate(today.getDate() - 3);

      if (approvalDate <= threeDaysAgo) {
        sheet.getRange(row, PRIORITY_COL).setValue("High Priority");
      } else {
        sheet.getRange(row, PRIORITY_COL).clearContent();
      }
    } else {
      sheet.getRange(row, PRIORITY_COL).clearContent();
    }
  }
}

// --- HELPER FUNCTIONS ---

/**
 * Inserts a new blank row at the top and sets its default status.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The sheet object.
 */
function insertNewRow_(sheet) {
  try {
    sheet.insertRowBefore(TARGET_ROW_FOR_INSERTION);
    sheet.getRange(TARGET_ROW_FOR_INSERTION, STATUS_COL).setValue(NEW_ROW_DEFAULT_STATUS);
  } catch (e) {
    console.error(`Error inserting row: ${e.message}`);
  }
}

/**
 * Sets the formula in the 'Days Remaining' column for a specific row.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The sheet object.
 * @param {number} row The row number that was edited.
 */
function updateDaysRemaining_(sheet, row) {
  const dateCell = sheet.getRange(row, APPROVAL_DATE_COL);
  const countdownCell = sheet.getRange(row, DAYS_REMAINING_COL);

  if (dateCell.isBlank()) {
    countdownCell.clearContent();
    return;
  }

  const dateCellA1 = dateCell.getA1Notation();
  const formula = `=IF(ISBLANK(${dateCellA1}), "", MAX(0, 28 - (TODAY() - ${dateCellA1})))`;
  countdownCell.setFormula(formula);
}

/**
 * Adds or removes the Welcome Call timestamp.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The sheet object.
 * @param {number} row The row number that was edited.
 * @param {string} newStatus The new value from the status dropdown.
 * @param {string} oldStatus The previous value from the status dropdown.
 */
function updateWelcomeCallTimestamp_(sheet, row, newStatus, oldStatus) {
  const wcDoneStatuses = ["SPP WC done", "PPL WC done", "Nas WC done"];
  const timestampCell = sheet.getRange(row, WC_DATE_COL);

  const isNowWcDone = wcDoneStatuses.includes(newStatus);
  const wasPreviouslyWcDone = wcDoneStatuses.includes(oldStatus);

  if (isNowWcDone && !wasPreviouslyWcDone) {
    timestampCell.setValue(new Date());
  } else if (!isNowWcDone && wasPreviouslyWcDone) {
    timestampCell.clearContent();
  }
}

/**
 * Sets the first follow-up date (7 weekdays from WC) or clears it.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The sheet object.
 * @param {number} row The row number.
 * @param {string} newStatus The new status.
 * @param {string} oldStatus The old status.
 */
function manageFirstFollowUpDate_(sheet, row, newStatus, oldStatus) {
  const wcDoneStatuses = ["SPP WC done", "PPL WC done", "Nas WC done"];
  const followUpCell = sheet.getRange(row, FOLLOW_UP_COL);

  const isNowWcDone = wcDoneStatuses.includes(newStatus);
  const wasPreviouslyWcDone = wcDoneStatuses.includes(oldStatus);

  if (isNowWcDone && !wasPreviouslyWcDone) {
    const followUpDate = getNextWeekday_(new Date(), 7);
    followUpCell.setValue(followUpDate).setNumberFormat("M/d/yyyy");
  } else if (!isNowWcDone && wasPreviouslyWcDone) {
    followUpCell.clearContent();
  }
}

/**
 * Sets the second follow-up date (22 days from approval).
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet The sheet object.
 * @param {number} row The row number.
 */
function manageSecondFollowUpDate_(sheet, row) {
  const approvalDateCell = sheet.getRange(row, APPROVAL_DATE_COL);
  if (approvalDateCell.isBlank()) return;

  const approvalDate = new Date(approvalDateCell.getValue());
  const followUpCell = sheet.getRange(row, FOLLOW_UP_COL);
  const secondFollowUpDate = getNextWeekday_(approvalDate, 22);
  followUpCell.setValue(secondFollowUpDate).setNumberFormat("M/d/yyyy");
}

/**
 * Calculates a future date, skipping weekends.
 * @param {Date} startDate The date to start from.
 * @param {number} daysToAdd The number of days to add.
 * @returns {Date} The calculated future date, guaranteed to be a weekday.
 */
function getNextWeekday_(startDate, daysToAdd) {
  const date = new Date(startDate);
  date.setDate(date.getDate() + daysToAdd);
  let dayOfWeek = date.getDay(); // Sunday = 0, Saturday = 6

  if (dayOfWeek === 6) { // It's a Saturday
    date.setDate(date.getDate() + 2); // Move to Monday
  } else if (dayOfWeek === 0) { // It's a Sunday
    date.setDate(date.getDate() + 1); // Move to Monday
  }
  return date;
}

/**
 * Applies background and font color formatting to a row based on its status.
 * @param {GoogleAppsScript.Spreadsheet.Range} targetRow The entire row range to format.
 * @param {string} status The value from the status dropdown.
 */
function applyRowFormatting_(targetRow, status) {
  let backgroundColor, fontColor;
  switch (status) {
    case "Not called":
      backgroundColor = "#c00000"; fontColor = "#ffffff"; break;
    case "SPP called":
      backgroundColor = "#ffc0cb"; fontColor = "#000000"; break;
    case "SPP WC done":
      backgroundColor = "#ffffff"; fontColor = "#ff00ff"; break;
    case "PPL Called":
      backgroundColor = "#add8e6"; fontColor = "#000000"; break;
    case "PPL WC done":
      backgroundColor = "#ffffff"; fontColor = "#00008b"; break;
    case "Nas called":
      backgroundColor = "#e6e6fa"; fontColor = "#000000"; break;
    case "Nas WC done":
      backgroundColor = "#ffffff"; fontColor = "#800080"; break;
    default:
      backgroundColor = "#ffffff"; fontColor = "#000000"; break;
  }
  try {
    targetRow.setBackground(backgroundColor).setFontColor(fontColor);
  } catch (e) {
    console.error(`Error applying row formatting: ${e.message}`);
  }
}
