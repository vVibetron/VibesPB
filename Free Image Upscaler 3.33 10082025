<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Image Upscaler 3.33</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- JSZip library to handle zip files in the browser -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Updated FileSaver.js library to save files to the local filesystem -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.5s ease;
            /* Halloween Theme */
            background-color: #0d0d0d !important;
            background-image: 
                radial-gradient(circle at 10% 10%, rgba(255, 165, 0, 0.05) 0%, transparent 30%),
                radial-gradient(circle at 90% 80%, rgba(128, 0, 128, 0.05) 0%, transparent 30%),
                url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><text y="50" x="50" font-size="80" fill="rgba(255,255,255,0.02)">ðŸŽƒ</text></svg>');
        }
        #app-title {
            font-family: 'Creepster', cursive;
            color: #ff7518; /* Pumpkin Orange */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .file-input-button { cursor: pointer; display: inline-flex; align-items: center; justify-content: center; transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s; }
        .drag-over { border-color: #ff7518; background-color: #4a2d04; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #2d2d2d; }
        ::-webkit-scrollbar-thumb { background: #ff7518; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #e66a15; }
        .preview-canvas { border: 2px dashed #4a5568; border-radius: 0.5rem; }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 117, 24, 0.7); }
            50% { box-shadow: 0 0 20px 10px rgba(255, 117, 24, 0); }
        }
        .pulse-animate { animation: pulse-glow 3s infinite; }
        .rotate-icon { transition: transform 0.3s ease-in-out; }
        .slider-wrapper { position: relative; display: flex; align-items: center; }
        .slider-wrapper::before { content: ''; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 2px; height: 12px; background-color: #9333ea; z-index: 1; }
        .slider-input { position: relative; z-index: 2; background: transparent; }
        input[type=range]::-webkit-slider-runnable-track { background: #4b5563; }
        input[type=range]::-moz-range-track { background: #4b5563; }
        .modal-backdrop { backdrop-filter: blur(5px); }
        .btn-compare-active { background-color: #ff7518 !important; color: white !important; font-weight: bold; }
        #framing-canvas { cursor: grab; }
        #framing-canvas:active { cursor: grabbing; }
        .halloween-decoration { position: absolute; opacity: 0.5; pointer-events: none; z-index: 0; }
        .halloween-font { font-family: 'Creepster', cursive; color: #ff7518; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-6xl bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-8 space-y-6 relative overflow-hidden">
        <!-- Decorations -->
        <svg class="halloween-decoration top-0 right-0 h-24 w-24 text-gray-700" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M21.92,10.15,19.3,7.53a1,1,0,0,0-1.42,0,1,1,0,0,0,0,1.41L19.3,10.36,15,6.06a1,1,0,0,0-1.41,0L12.17,7.48,11.5,6.81a1,1,0,0,0-1.41,0L8.68,8.22,6.06,5.6A1,1,0,0,0,4.64,5.6a1,1,0,0,0,0,1.41L7.26,9.63,2.08,10.15a1,1,0,0,0-.81,1.52,9,9,0,0,0,20.46,0,1,1,0,0,0-.81-1.52ZM12,19.5A7,7,0,0,1,5.26,13.11L5.89,12h12.2l.65,1.11A7,7,0,0,1,12,19.5Z"/></svg>
        <svg class="halloween-decoration bottom-2 left-2 h-16 w-16 text-gray-700 transform scale-x-[-1]" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M21.92,10.15,19.3,7.53a1,1,0,0,0-1.42,0,1,1,0,0,0,0,1.41L19.3,10.36,15,6.06a1,1,0,0,0-1.41,0L12.17,7.48,11.5,6.81a1,1,0,0,0-1.41,0L8.68,8.22,6.06,5.6A1,1,0,0,0,4.64,5.6a1,1,0,0,0,0,1.41L7.26,9.63,2.08,10.15a1,1,0,0,0-.81,1.52,9,9,0,0,0,20.46,0,1,1,0,0,0-.81-1.52ZM12,19.5A7,7,0,0,1,5.26,13.11L5.89,12h12.2l.65,1.11A7,7,0,0,1,12,19.5Z"/></svg>
        <div class="halloween-decoration bottom-0 right-0 text-6xl opacity-20 -mr-2 -mb-2">ðŸŽƒ</div>

        <button id="instructions-btn" class="absolute top-4 left-4 px-4 py-2 bg-gray-700/50 rounded-lg hover:bg-gray-600 transition-colors text-sm font-semibold z-10" title="Instructions">
            Instruction Manual
        </button>

        <div class="text-center pt-8">
            <h1 id="app-title" class="text-3xl md:text-5xl font-bold text-white">Free Image Upscaler 3.33</h1>
            <p class="text-gray-400 mt-2">Enlarge, edit, frame, and compare your JPG & PNG images.</p>
        </div>

        <div class="bg-gray-700/50 p-6 rounded-xl grid grid-cols-1 md:grid-cols-4 gap-6 items-start">
            <div class="space-y-2">
                <label class="text-lg font-semibold text-white">1. Add SPID (Optional)</label>
                <input type="text" id="spid-input" maxlength="17" placeholder="SPID" class="w-full bg-gray-800 border border-gray-600 text-white rounded-lg px-4 py-2 focus:ring-2 focus:ring-orange-500 focus:outline-none transition">
                <label class="text-lg font-semibold text-white mt-4 block">2. Upload Images</label>
                <input type="file" id="image-files-input" multiple accept=".png,.jpg,.jpeg,.webp,.gif,.bmp,.svg,.avif" class="hidden">
                <label for="image-files-input" id="drop-zone" class="file-input-button w-full text-center px-4 py-3 bg-orange-600 text-white rounded-lg hover:bg-orange-700 font-semibold flex flex-col items-center justify-center border-2 border-dashed border-transparent h-28 pulse-animate">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-2 text-orange-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-4-4V7a4 4 0 014-4h10a4 4 0 014 4v5a4 4 0 01-4 4H7z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M16 16v-4a4 4 0 00-4-4H8a4 4 0 00-4 4v4"></path></svg>
                    <span>Select Images or Drag & Drop</span>
                </label>
                <p id="file-selection-text" class="text-gray-400 text-sm text-center">No images selected.</p>
            </div>
            <div class="space-y-2">
                <label class="text-lg font-semibold text-white">3. Choose Scale Factor</label>
                <div id="scale-factor" class="flex justify-center bg-gray-800 rounded-lg p-1">
                    <label class="flex-1 text-center cursor-pointer py-2 rounded-md transition-colors" for="2x"><input type="radio" name="scale" value="2" id="2x" class="sr-only" checked>2x</label>
                    <label class="flex-1 text-center cursor-pointer py-2 rounded-md transition-colors" for="4x"><input type="radio" name="scale" value="4" id="4x" class="sr-only">4x</label>
                    <label class="flex-1 text-center cursor-pointer py-2 rounded-md transition-colors" for="8x"><input type="radio" name="scale" value="8" id="8x" class="sr-only">8x</label>
                </div>
            </div>
            <div class="space-y-2 col-span-1 md:col-span-2">
                 <label class="text-lg font-semibold text-white">4. Process Images</label>
                 <div class="grid grid-cols-2 gap-4">
                     <button id="upscale-btn" class="w-full px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors duration-300 font-bold text-lg disabled:bg-gray-500 disabled:cursor-not-allowed">Upscale</button>
                     <button id="clear-btn" class="w-full px-4 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors duration-300 font-bold text-lg">Clear</button>
                </div>
            </div>
        </div>
        
        <div id="loading-spinner" class="hidden text-center py-4">
            <svg class="animate-spin h-8 w-8 text-orange-400 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p class="mt-2 text-lg font-semibold">Upscaling... Please wait.</p>
        </div>
        
        <div id="results-header" class="hidden justify-between items-center mt-4">
            <h2 class="text-2xl font-bold">Upscaled Previews & Editors</h2>
            <button id="download-all-btn" class="px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700 transition-colors duration-300 font-semibold flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                Download All as Zip
            </button>
        </div>
        <div id="results-container" class="bg-gray-900/70 p-4 rounded-xl min-h-[200px] max-h-[60vh] overflow-y-auto space-y-4">
            <p id="results-placeholder" class="text-gray-500 text-center py-10">Your upscaled images will appear here.</p>
        </div>

        <div id="feedback-section" class="hidden bg-gray-700/50 p-6 rounded-xl mt-6 space-y-4 text-center">
            <h2 class="text-2xl font-bold">Feedback & Support</h2>
            <p class="text-gray-300">Encounter an issue or have feedback? Please email <strong class="text-orange-300">Brian.Shirley@Angi.com</strong>.</p>
            <button id="copy-diagnostics-btn" class="w-full sm:w-auto mx-auto px-6 py-3 bg-orange-600 text-white rounded-lg hover:bg-orange-700 transition-colors duration-300 font-bold">Copy Diagnostic Info</button>
        </div>
    </div>

    <!-- Modals -->
    <div id="instructions-modal" class="modal-backdrop hidden fixed inset-0 bg-gray-900/80 flex items-center justify-center z-50 p-4">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-bold text-center mb-4 halloween-font text-3xl">How to Use Free Image Upscaler 3.33</h2>
            <div class="prose prose-invert text-gray-300 max-w-none space-y-4">
                <h3 class="font-bold text-white">1. Uploading Images</h3>
                <p>Click the 'Select Images or Drag & Drop' area to open a file dialog, or drag image files directly onto it. You can upload multiple JPG, PNG, WEBP, GIF, and other common formats.</p>
                <p class="text-sm text-yellow-400"><strong>Note:</strong> This tool cannot process non-image files like PDFs. Please convert them to an image format first.</p>

                <h3 class="font-bold text-white">2. Upscaling</h3>
                <p>Choose a scale factor (2x, 4x, or 8x) and click the 'Upscale' button. Your images will be processed and previews will appear below. For large batches, images are lazy-loaded as you scroll for better performance.</p>

                <h3 class="font-bold text-white">3. Editing Your Image</h3>
                <p>Each upscaled image has its own editing panel. You can:</p>
                <ul>
                    <li><strong>Rotate:</strong> Click the rotate button to turn the image 90 degrees clockwise.</li>
                    <li><strong>Brightness & Sharpen:</strong> Use the sliders to make fine adjustments.</li>
                    <li><strong>Reset Edits:</strong> Click to revert all edits on that specific image.</li>
                </ul>

                <h3 class="font-bold text-white">4. Framing a Logo (4:3 Ratio)</h3>
                <p>Click the 'Fix Logo' button to open the framing tool. You have two modes:</p>
                <ul>
                    <li><strong>Make Logo Square (Letterbox):</strong> The image is scaled to fit inside the 4:3 frame, preserving the whole picture. Use the color picker and eyedropper tool to fill the background space with a matching color.</li>
                    <li><strong>Zoom (Crop):</strong> The image fills the entire 4:3 frame. Click and drag to pan the image, and use your mouse wheel to zoom in and out to find the perfect crop.</li>
                </ul>

                <h3 class="font-bold text-white">5. Comparing & Downloading</h3>
                <ul>
                    <li><strong>Set Before/After:</strong> Click these buttons on any two cards to generate a side-by-side comparison image.</li>
                    <li><strong>Download JPG/PNG:</strong> Download individual images in your desired format. The tool will automatically ensure the final file is at least 450 KB.</li>
                    <li><strong>Download All as Zip:</strong> Packages all your edited images into a single .zip file.</li>
                </ul>
                <hr class="border-gray-600">
                <p class="text-xs text-gray-500 text-center"><em>This instruction manual was generated by AI and may not be perfect. If you find any issues or have suggestions, please click the 'Copy Diagnostic Info' button on the main page and email us with the report and your feedback.</em></p>
                <p class="text-center text-2xl halloween-font">Have a Scary Day!</p>
            </div>
             <div class="mt-6 flex justify-center">
                <button id="close-instructions-btn" class="px-6 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-semibold">Close</button>
            </div>
        </div>
    </div>

    <div id="comparison-modal" class="modal-backdrop hidden fixed inset-0 bg-gray-900/80 flex items-center justify-center z-50 p-4">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 w-full max-w-5xl max-h-full overflow-y-auto">
            <h2 class="text-2xl font-bold text-center mb-4">Image Comparison</h2>
            <div id="comparison-canvas-container" class="bg-gray-900 p-4 rounded-lg"></div>
            <div class="mt-6 flex justify-center gap-4">
                <button id="download-comparison-btn" class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 font-semibold">Download Comparison</button>
                <button id="close-modal-btn" class="px-6 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-semibold">Close</button>
            </div>
        </div>
    </div>
    
    <div id="framing-modal" class="modal-backdrop hidden fixed inset-0 bg-gray-900/80 flex items-center justify-center z-50 p-4">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 w-full max-w-4xl">
            <h2 class="text-2xl font-bold text-center mb-4">Frame Logo to 4:3</h2>
            <div class="flex justify-center mb-4 gap-2">
                <button id="framing-mode-fit" class="px-4 py-2 text-sm font-bold rounded-lg bg-gray-600 text-white">Make Logo Square</button>
                <button id="framing-mode-fill" class="px-4 py-2 text-sm font-bold rounded-lg bg-orange-600 text-white">Zoom</button>
            </div>
            <div id="framing-canvas-container" class="bg-gray-900 rounded-lg flex justify-center items-center" style="height: 480px;"></div>
            <div id="fit-controls" class="hidden items-center justify-center gap-4 mt-4">
                <label for="bg-color-picker" class="font-semibold">Background Color:</label>
                <input type="color" id="bg-color-picker" value="#111827">
                <button id="eyedropper-btn" class="p-2 bg-gray-600 rounded-md hover:bg-gray-500" title="Pick color from image">
                    <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12.7,12.72a1,1,0,0,0,1.41,0l5-4.95A1,1,0,0,0,19.12,6.36L14.5,11,13.06,9.58a1,1,0,0,0-1.41,0L3.29,18,2,22l4-1.29,8.36-8.36A1,1,0,0,0,12.7,12.72Z"/></svg>
                </button>
            </div>
            <div class="mt-6 flex justify-center gap-4">
                <button id="apply-framing-btn" class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 font-semibold">Apply</button>
                <button id="cancel-framing-btn" class="px-6 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-semibold">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- VERSIONING ---
        // REMINDER: Increment this version number with each update. Full number for significant changes, decimal for minor fixes.
        const APP_VERSION = 3.33; 
        const versionColors = ['#1a1a1a', '#1F2937', '#374151', '#4B5563', '#1F2937'];
        document.body.style.backgroundColor = versionColors[Math.floor(APP_VERSION) % versionColors.length];
        document.getElementById('app-title').textContent = `Free Image Upscaler ${APP_VERSION.toFixed(2)}`;
        
        // --- DOM Element References ---
        const imageInput = document.getElementById('image-files-input'), spidInput = document.getElementById('spid-input'),
              fileSelectionText = document.getElementById('file-selection-text'), upscaleBtn = document.getElementById('upscale-btn'),
              clearBtn = document.getElementById('clear-btn'), scaleFactorContainer = document.getElementById('scale-factor'),
              loadingSpinner = document.getElementById('loading-spinner'), resultsContainer = document.getElementById('results-container'),
              resultsHeader = document.getElementById('results-header'), downloadAllBtn = document.getElementById('download-all-btn'),
              resultsPlaceholder = document.getElementById('results-placeholder'), dropZone = document.getElementById('drop-zone'),
              feedbackSection = document.getElementById('feedback-section'), copyDiagnosticsBtn = document.getElementById('copy-diagnostics-btn'),
              instructionsBtn = document.getElementById('instructions-btn'), instructionsModal = document.getElementById('instructions-modal'),
              closeInstructionsBtn = document.getElementById('close-instructions-btn'),
              comparisonModal = document.getElementById('comparison-modal'),
              comparisonCanvasContainer = document.getElementById('comparison-canvas-container'), closeModalBtn = document.getElementById('close-modal-btn'),
              downloadComparisonBtn = document.getElementById('download-comparison-btn'),
              framingModal = document.getElementById('framing-modal'), framingModeFill = document.getElementById('framing-mode-fill'),
              framingModeFit = document.getElementById('framing-mode-fit'), framingCanvasContainer = document.getElementById('framing-canvas-container'),
              fitControls = document.getElementById('fit-controls'), bgColorPicker = document.getElementById('bg-color-picker'),
              eyedropperBtn = document.getElementById('eyedropper-btn'), applyFramingBtn = document.getElementById('apply-framing-btn'),
              cancelFramingBtn = document.getElementById('cancel-framing-btn');

        // --- Global State ---
        const upscaledCanvases = new Map();
        let diagnostics = {}, intersectionObserver, beforeImageId = null, afterImageId = null, comparisonBlob = null;
        
        const MIN_SIZE_BYTES = 450 * 1024, MAX_RESCALE_ATTEMPTS = 5, RESCALE_FACTOR = 1.15, MAX_DIMENSION = 8000;
        let framingState = {};

        // --- Initialization ---
        window.addEventListener('load', () => { initializeDiagnostics(); });
        
        function initializeDiagnostics() {
            diagnostics = { appVersion: APP_VERSION, sessionId: crypto.randomUUID(), pageLoadTimestamp: new Date().toISOString(), sessionDuration: null, browserInfo: navigator.userAgent, screenResolution: `${window.screen.width}x${window.screen.height}`, timeToFirstUpload: null, uploadMethod: null, timeFromUploadToProcess: null, scaleChanges: 0, mostUsedScaleFactor: null, individualDownloads: 0, downloadAllClicked: false, scrollDepth: 0, timeSpentOnPreviews: null, sessionAbandoned: true, mousePath: [], totalProcessingTime: null, totalUpscaledOutputSize: 0, processingErrors: [], imageReports: [], editActions: [] };
        }

        // --- Event Listeners ---
        window.addEventListener('beforeunload', () => {
            if (diagnostics.pageLoadTimestamp) diagnostics.sessionDuration = `${(Date.now() - new Date(diagnostics.pageLoadTimestamp).getTime()) / 1000} seconds`;
            if (diagnostics.timeSpentOnPreviewsStart) diagnostics.timeSpentOnPreviews = `${(Date.now() - diagnostics.timeSpentOnPreviewsStart) / 1000} seconds`;
        });
        imageInput.addEventListener('change', () => {
            if (!diagnostics.timeToFirstUpload) {
                diagnostics.timeToFirstUpload = `${(Date.now() - new Date(diagnostics.pageLoadTimestamp).getTime()) / 1000} seconds`;
                diagnostics.timeFromUploadToProcess = Date.now();
            }
            if (!diagnostics.uploadMethod) diagnostics.uploadMethod = 'ButtonClick';
            updateFileSelectionUI(imageInput.files);
        });
        scaleFactorContainer.addEventListener('change', (e) => {
            if (e.target.type === 'radio') {
                diagnostics.scaleChanges++;
                document.querySelectorAll('#scale-factor label').forEach(label => { label.style.backgroundColor = ''; label.style.color = ''; });
                e.target.parentElement.style.backgroundColor = '#ff7518'; e.target.parentElement.style.color = 'white';
            }
        });
        document.querySelector('#scale-factor input:checked').parentElement.style.backgroundColor = '#ff7518';
        document.querySelector('#scale-factor input:checked').parentElement.style.color = 'white';
        upscaleBtn.addEventListener('click', handleUpscaleProcess);
        clearBtn.addEventListener('click', handleClear);
        downloadAllBtn.addEventListener('click', () => { diagnostics.downloadAllClicked = true; downloadAllAsZip(); });
        resultsContainer.addEventListener('scroll', () => {
            const { scrollTop, scrollHeight, clientHeight } = resultsContainer;
            const currentDepth = Math.round(((scrollTop + clientHeight) / scrollHeight) * 100);
            if (currentDepth > diagnostics.scrollDepth) diagnostics.scrollDepth = currentDepth;
        });
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => { dropZone.addEventListener(eventName, preventDefaults, false); document.body.addEventListener(eventName, preventDefaults, false); });
        ['dragenter', 'dragover'].forEach(eventName => dropZone.addEventListener(eventName, () => dropZone.classList.add('drag-over'), false));
        ['dragleave', 'drop'].forEach(eventName => dropZone.addEventListener(eventName, () => dropZone.classList.remove('drag-over'), false));
        dropZone.addEventListener('drop', handleDrop, false);
        
        instructionsBtn.addEventListener('click', () => instructionsModal.classList.remove('hidden'));
        closeInstructionsBtn.addEventListener('click', () => instructionsModal.classList.add('hidden'));

        closeModalBtn.addEventListener('click', () => { comparisonModal.classList.add('hidden'); resetComparisonSelection(); });
        downloadComparisonBtn.addEventListener('click', downloadComparisonImage);
        
        framingModeFill.addEventListener('click', () => switchFramingMode('fill'));
        framingModeFit.addEventListener('click', () => switchFramingMode('fit'));
        bgColorPicker.addEventListener('input', () => { framingState.bgColor = bgColorPicker.value; drawFramingCanvas(); });
        eyedropperBtn.addEventListener('click', activateEyedropper);
        applyFramingBtn.addEventListener('click', applyFraming);
        cancelFramingBtn.addEventListener('click', () => framingModal.classList.add('hidden'));

        // --- Core Functions ---
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

        function handleDrop(e) {
            diagnostics.uploadMethod = 'DragAndDrop';
            const files = e.dataTransfer.files;
            const dataTransfer = new DataTransfer();
            Array.from(files).filter(file => file.type.startsWith('image/')).forEach(file => dataTransfer.items.add(file));
            imageInput.files = dataTransfer.files;
            imageInput.dispatchEvent(new Event('change', { bubbles: true }));
        }

        function updateFileSelectionUI(files) {
            const count = files.length;
            fileSelectionText.textContent = count > 0 ? `${count} image(s) selected.` : 'No images selected.';
            fileSelectionText.classList.toggle('text-green-400', count > 0);
        }

        function handleClear() {
            imageInput.value = null;
            updateFileSelectionUI(imageInput.files);
            resultsContainer.innerHTML = `<p id="results-placeholder" class="text-gray-500 text-center py-10">Your upscaled images will appear here.</p>`;
            resultsHeader.classList.add('hidden');
            feedbackSection.classList.add('hidden');
            spidInput.value = '';
            upscaledCanvases.clear();
            resetComparisonSelection();
            initializeDiagnostics();
        }

        async function handleUpscaleProcess() {
            const files = imageInput.files;
            if (files.length === 0) {
                fileSelectionText.style.color = '#f87171'; fileSelectionText.style.fontWeight = 'bold';
                fileSelectionText.textContent = 'Please select at least one image file.';
                setTimeout(() => { fileSelectionText.style.color = ''; fileSelectionText.style.fontWeight = ''; updateFileSelectionUI(imageInput.files); }, 3000);
                return;
            }
            diagnostics.sessionAbandoned = false;
            diagnostics.mostUsedScaleFactor = `${document.querySelector('input[name="scale"]:checked').value}x`;
            if (diagnostics.timeFromUploadToProcess && typeof diagnostics.timeFromUploadToProcess === 'number') {
                diagnostics.timeFromUploadToProcess = `${(Date.now() - diagnostics.timeFromUploadToProcess) / 1000} seconds`;
            }
            upscaleBtn.disabled = true; upscaleBtn.textContent = 'Processing...';
            loadingSpinner.classList.remove('hidden');
            resultsContainer.innerHTML = ''; resultsHeader.classList.add('hidden');
            feedbackSection.classList.add('hidden'); 
            upscaledCanvases.clear(); resetComparisonSelection();
            
            diagnostics.imageReports = []; diagnostics.processingErrors = []; diagnostics.totalUpscaledOutputSize = 0;

            const placeholders = Array.from(files).map((file, index) => {
                const placeholder = document.createElement('div');
                placeholder.id = `card-${index}`;
                placeholder.className = 'bg-gray-800 p-4 rounded-lg min-h-[200px] flex items-center justify-center';
                placeholder.innerHTML = `<p class="text-gray-500">Queued: ${file.name}...</p>`;
                resultsContainer.appendChild(placeholder);
                return { file, index, placeholder };
            });

            if (intersectionObserver) intersectionObserver.disconnect();
            intersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const placeholder = entry.target;
                        const fileData = placeholders.find(p => p.placeholder === placeholder);
                        if (fileData && !fileData.processed) {
                            fileData.processed = true;
                            placeholder.innerHTML = `<p class="text-gray-400 animate-pulse">Processing ${fileData.file.name}...</p>`;
                            const scaleFactor = parseInt(document.querySelector('input[name="scale"]:checked').value);
                            createImagePreview(fileData.file, scaleFactor, fileData.index)
                                .then(result => {
                                    if (result) {
                                        placeholder.replaceWith(result.previewElement);
                                        diagnostics.imageReports[result.report.index] = result.report;
                                    }
                                }).catch(handleProcessingError(fileData.file, placeholder));
                        }
                    }
                });
            }, { root: resultsContainer, rootMargin: '200px' });

            placeholders.forEach(p => intersectionObserver.observe(p.placeholder));

            upscaleBtn.disabled = false; upscaleBtn.textContent = 'Upscale';
            loadingSpinner.classList.add('hidden');
            if (files.length > 0) {
                resultsHeader.classList.remove('hidden'); resultsHeader.classList.add('flex');
                feedbackSection.classList.remove('hidden');
                diagnostics.timeSpentOnPreviewsStart = Date.now();
            }
        }
        
        function handleProcessingError(file, placeholder) {
            return (error) => {
                console.error('Error processing file:', file.name, error);
                diagnostics.processingErrors.push(file.name);
                const errorCard = document.createElement('div');
                errorCard.className = 'bg-red-900/50 p-4 rounded-lg text-center';
                errorCard.innerHTML = `<p class="font-bold text-red-300">Failed to process:</p><p class="text-sm truncate">${file.name}</p><p class="text-xs text-red-400 mt-1">File may be corrupted.</p>`;
                placeholder.replaceWith(errorCard);
            };
        }

        function createImagePreview(file, scaleFactor, index) {
            return new Promise((resolve, reject) => {
                const individualStartTime = Date.now();
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        let originalWidth = img.width, originalHeight = img.height;
                        let newWidth = originalWidth * scaleFactor, newHeight = originalHeight * scaleFactor;
                        if (newWidth > MAX_DIMENSION || newHeight > MAX_DIMENSION) {
                            const ratio = Math.min(MAX_DIMENSION / newWidth, MAX_DIMENSION / newHeight);
                            newWidth = Math.floor(newWidth * ratio); newHeight = Math.floor(newHeight * ratio);
                        }
                        const canvas = document.createElement('canvas');
                        canvas.width = newWidth; canvas.height = newHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, newWidth, newHeight);
                        
                        const cardId = `card-${index}`;
                        upscaledCanvases.set(cardId, { originalImage: img, canvas: canvas, rotation: 0, brightness: 0, sharpness: 0, fileName: file.name, fileType: file.type });
                        const previewContainer = document.createElement('div');
                        previewContainer.className = 'bg-gray-800 p-4 rounded-lg transition-shadow';
                        previewContainer.id = cardId;
                        previewContainer.innerHTML = `
                            <div class="relative grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
                                <button class="rotate-btn absolute top-2 right-2 z-10 p-2 bg-gray-900/50 rounded-full hover:bg-gray-700/70 transition-colors flex items-center space-x-1" title="Rotate"><svg class="rotate-icon w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M18 6 L18 18 L6 18"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M10 14 L6 18 L10 22"></path></svg><span class="text-xs font-semibold text-white">90Â°</span></button>
                                <div class="text-center"><h3 class="font-bold text-lg mb-2">Original</h3><img src="${img.src}" class="max-w-full h-auto mx-auto rounded-md"><p class="text-sm text-gray-400 mt-2">${originalWidth} x ${originalHeight}px</p></div>
                                <div class="text-center upscaled-container"><h3 class="font-bold text-lg mb-2">Upscaled (${scaleFactor}x)</h3></div>
                            </div>
                            <div class="mt-4 pt-4 border-t border-gray-700 space-y-4">
                                <div><label class="text-sm font-semibold text-gray-300">Brightness</label><div class="flex items-center gap-2"><span class="text-xs">Darker</span><div class="slider-wrapper w-full"><input type="range" min="-100" max="100" value="0" class="slider-input brightness-slider w-full"></div><span class="text-xs">Lighter</span></div></div>
                                <div><label class="text-sm font-semibold text-gray-300">Sharpen</label><div class="flex items-center gap-2"><span class="text-xs">Softer</span><div class="slider-wrapper w-full"><input type="range" min="-100" max="100" value="0" class="slider-input sharpen-slider w-full"></div><span class="text-xs">Sharper</span></div></div>
                                <div class="text-center"><button class="reset-btn mt-1 px-4 py-1 bg-red-600 text-white text-xs font-bold rounded-full hover:bg-red-700 transition-colors">Reset Edits</button></div>
                            </div>
                            <div class="mt-4 flex justify-end items-center gap-2 flex-wrap">
                                <button class="frame-btn px-3 py-1.5 bg-purple-600 text-white text-sm rounded-md hover:bg-purple-700 font-semibold transition-colors">Fix Logo</button>
                                <button class="before-btn px-3 py-1.5 bg-gray-600 text-white text-sm rounded-md hover:bg-gray-700 font-semibold transition-colors">Set Before</button>
                                <button class="after-btn px-3 py-1.5 bg-gray-600 text-white text-sm rounded-md hover:bg-gray-700 font-semibold transition-colors">Set After</button>
                                <button class="download-jpg-btn px-3 py-1.5 bg-blue-600 text-white text-sm rounded-md hover:bg-blue-700 font-semibold">Download JPG</button>
                                <button class="download-png-btn px-3 py-1.5 bg-green-600 text-white text-sm rounded-md hover:bg-green-700 font-semibold">Download PNG</button>
                            </div>`;
                        
                        const upscaledContainer = previewContainer.querySelector('.upscaled-container');
                        upscaledContainer.appendChild(canvas);
                        canvas.className = 'max-w-full h-auto mx-auto rounded-md preview-canvas';

                        const rotateBtnIcon = previewContainer.querySelector('.rotate-icon');
                        previewContainer.querySelector('.rotate-btn').addEventListener('click', () => {
                            const state = upscaledCanvases.get(cardId); state.rotation = (state.rotation + 90) % 360;
                            diagnostics.editActions.push({ file: state.fileName, action: 'rotate', value: state.rotation, timestamp: Date.now() });
                            rotateBtnIcon.style.transform = `rotate(${state.rotation}deg)`; redrawCanvas(cardId);
                        });
                        
                        const brightnessSlider = previewContainer.querySelector('.brightness-slider'), sharpenSlider = previewContainer.querySelector('.sharpen-slider');
                        const handleSliderInput = (e, property) => {
                            let debounceTimer;
                            clearTimeout(debounceTimer);
                            debounceTimer = setTimeout(() => {
                                const state = upscaledCanvases.get(cardId); state[property] = parseInt(e.target.value);
                                diagnostics.editActions.push({ file: state.fileName, action: property, value: state[property], timestamp: Date.now() });
                                redrawCanvas(cardId);
                            }, 50);
                        };
                        brightnessSlider.addEventListener('input', (e) => handleSliderInput(e, 'brightness'));
                        sharpenSlider.addEventListener('input', (e) => handleSliderInput(e, 'sharpness'));
                        
                        previewContainer.querySelector('.reset-btn').addEventListener('click', () => {
                            const state = upscaledCanvases.get(cardId); state.brightness = 0; state.sharpness = 0;
                            brightnessSlider.value = 0; sharpenSlider.value = 0;
                            diagnostics.editActions.push({ file: state.fileName, action: 'resetEdits', timestamp: Date.now() });
                            redrawCanvas(cardId);
                        });
                        
                        previewContainer.querySelector('.frame-btn').addEventListener('click', () => openFramingModal(cardId));
                        previewContainer.querySelector('.download-jpg-btn').addEventListener('click', (e) => downloadImage(cardId, 'jpeg', e.target));
                        previewContainer.querySelector('.download-png-btn').addEventListener('click', (e) => downloadImage(cardId, 'png', e.target));
                        previewContainer.querySelector('.before-btn').addEventListener('click', () => handleBeforeClick(cardId));
                        previewContainer.querySelector('.after-btn').addEventListener('click', () => handleAfterClick(cardId));
                        
                        const report = { index, fileName: file.name, fileType: file.type, originalDimensions: `${originalWidth}x${originalHeight}`, upscaledDimensions: `${newWidth}x${newHeight}`, aspectRatio: (originalWidth / originalHeight).toFixed(2), originalSize: `${(file.size / 1024).toFixed(2)} KB`, upscaledSize: 'N/A', rawUpscaledSize: 0, totalPixelsProcessed: newWidth * newHeight, processingTime: `${Date.now() - individualStartTime} ms` };
                        resolve({ previewElement: previewContainer, report: report });
                    };
                    img.onerror = reject; img.src = e.target.result;
                };
                reader.onerror = reject; reader.readAsDataURL(file);
            });
        }
        
        function redrawCanvas(cardId) {
            const state = upscaledCanvases.get(cardId); if (!state) return;
            const { originalImage, canvas, rotation, brightness, sharpness } = state;
            const ctx = canvas.getContext('2d');
            
            const scaleFactor = Math.sqrt((canvas.width * canvas.height) / (originalImage.width * originalImage.height));
            let newWidth = (rotation === 90 || rotation === 270) ? originalImage.height * scaleFactor : originalImage.width * scaleFactor;
            let newHeight = (rotation === 90 || rotation === 270) ? originalImage.width * scaleFactor : originalImage.height * scaleFactor;

            canvas.width = newWidth;
            canvas.height = newHeight;

            const brightnessValue = 100 + (brightness / 2), contrastValue = 100 + (sharpness / 5);
            ctx.filter = `brightness(${brightnessValue}%) contrast(${contrastValue}%)`;
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(rotation * Math.PI / 180);
            
            const drawWidth = (rotation === 90 || rotation === 270) ? canvas.height : canvas.width;
            const drawHeight = (rotation === 90 || rotation === 270) ? canvas.width : canvas.height;
            
            ctx.drawImage(originalImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
            ctx.restore();
        }
        
        function drawStateOnCanvas(targetCanvas, state) {
            const ctx = targetCanvas.getContext('2d');
            const { originalImage, rotation, brightness, sharpness } = state;

            ctx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
            const brightnessValue = 100 + (brightness / 2);
            const contrastValue = 100 + (sharpness / 5);
            ctx.filter = `brightness(${brightnessValue}%) contrast(${contrastValue}%)`;
            ctx.save();
            ctx.translate(targetCanvas.width / 2, targetCanvas.height / 2);
            ctx.rotate(rotation * Math.PI / 180);
            const w = (rotation === 90 || rotation === 270) ? targetCanvas.height : targetCanvas.width;
            const h = (rotation === 90 || rotation === 270) ? targetCanvas.width : targetCanvas.height;
            ctx.drawImage(originalImage, -w / 2, -h / 2, w, h);
            ctx.restore();
        }
        
        async function getSizedBlob(cardId, format) {
            const state = upscaledCanvases.get(cardId);
            if (!state) return null;
            
            let tempCanvas = document.createElement('canvas');
            let tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = state.canvas.width;
            tempCanvas.height = state.canvas.height;
            
            let blob, attempts = 0;

            while (attempts < MAX_RESCALE_ATTEMPTS) {
                drawStateOnCanvas(tempCanvas, state);
                blob = await new Promise(resolve => tempCanvas.toBlob(resolve, `image/${format}`, 1.0));
                if (blob.size >= MIN_SIZE_BYTES) return { blob, width: tempCanvas.width, height: tempCanvas.height };

                attempts++;
                const newWidth = Math.min(Math.floor(tempCanvas.width * RESCALE_FACTOR), MAX_DIMENSION);
                const newHeight = Math.min(Math.floor(tempCanvas.height * RESCALE_FACTOR), MAX_DIMENSION);

                if (newWidth === tempCanvas.width && newHeight === tempCanvas.height) break;
                tempCanvas.width = newWidth;
                tempCanvas.height = newHeight;
            }

            drawStateOnCanvas(tempCanvas, state);
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = Math.floor(Math.random() * 5) - 2;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
                data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
            }
            tempCtx.putImageData(imageData, 0, 0);
            blob = await new Promise(resolve => tempCanvas.toBlob(resolve, `image/${format}`, 1.0));
            return { blob, width: tempCanvas.width, height: tempCanvas.height };
        }

        async function downloadImage(cardId, format, btnElement) {
            diagnostics.individualDownloads++;
            const originalText = btnElement.textContent;
            btnElement.textContent = 'Sizing...';
            btnElement.disabled = true;

            try {
                const { blob, width, height } = await getSizedBlob(cardId, format);
                if (!blob) throw new Error("Blob creation failed.");

                const state = upscaledCanvases.get(cardId);
                const spid = spidInput.value.trim();
                const scaleFactor = (state.rotation === 0 || state.rotation === 180) ? width / state.originalImage.width : width / state.originalImage.height;
                const baseFileName = state.fileName.split('.').slice(0, -1).join('.') || state.fileName;
                const finalFileName = `${spid ? spid + '_' : ''}upscaled_${scaleFactor.toFixed(1)}x_${baseFileName}.${format}`;
                
                const report = diagnostics.imageReports.find(r => r && r.fileName === state.fileName);
                if (report) {
                    report.upscaledSize = `${(blob.size / 1024).toFixed(2)} KB`;
                    report.rawUpscaledSize = blob.size;
                }
                saveAs(blob, finalFileName);
            } catch (error) {
                console.error("Download failed:", error);
                btnElement.textContent = 'Error!';
                setTimeout(() => { btnElement.textContent = originalText; }, 2000);
            } finally {
                if(btnElement.textContent !== 'Error!') btnElement.textContent = originalText;
                btnElement.disabled = false;
            }
        }
        
        function openFramingModal(cardId) {
            const state = upscaledCanvases.get(cardId);
            if (!state) return;

            framingState = {
                cardId: cardId,
                mode: 'fill', 
                img: state.originalImage, 
                edits: { rotation: state.rotation, brightness: state.brightness, sharpness: state.sharpness },
                bgColor: '#111827',
                zoom: 1, offsetX: 0, offsetY: 0, isDragging: false, lastX: 0, lastY: 0,
            };

            const canvas = document.createElement('canvas');
            canvas.id = 'framing-canvas';
            framingCanvasContainer.innerHTML = '';
            framingCanvasContainer.appendChild(canvas);

            switchFramingMode('fill');
            framingModal.classList.remove('hidden');

            canvas.addEventListener('mousedown', (e) => {
                if (framingState.mode === 'fill') {
                    framingState.isDragging = true;
                    framingState.lastX = e.clientX;
                    framingState.lastY = e.clientY;
                }
            });
            canvas.addEventListener('mousemove', (e) => {
                if (framingState.isDragging && framingState.mode === 'fill') {
                    const dx = e.clientX - framingState.lastX;
                    const dy = e.clientY - framingState.lastY;
                    framingState.offsetX += dx;
                    framingState.offsetY += dy;
                    framingState.lastX = e.clientX;
                    framingState.lastY = e.clientY;
                    drawFramingCanvas();
                }
            });
            canvas.addEventListener('mouseup', () => framingState.isDragging = false);
            canvas.addEventListener('mouseleave', () => framingState.isDragging = false);
            canvas.addEventListener('wheel', (e) => {
                if (framingState.mode === 'fill') {
                    e.preventDefault();
                    const zoomFactor = 1.1;
                    const zoom = e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
                    framingState.zoom = Math.max(1, framingState.zoom * zoom);
                    drawFramingCanvas();
                }
            });
        }

        function switchFramingMode(mode) {
            framingState.mode = mode;
            framingModeFill.classList.toggle('bg-orange-600', mode === 'fill');
            framingModeFill.classList.toggle('bg-gray-600', mode !== 'fill');
            framingModeFit.classList.toggle('bg-orange-600', mode === 'fit');
            framingModeFit.classList.toggle('bg-gray-600', mode !== 'fit');
            fitControls.classList.toggle('hidden', mode !== 'fit');
            framingState.zoom = 1; framingState.offsetX = 0; framingState.offsetY = 0;
            drawFramingCanvas();
        }

        function drawFramingCanvas() {
            const canvas = document.getElementById('framing-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const container = framingCanvasContainer;
            const img = framingState.img;
            
            const targetRatio = 4 / 3;
            let canvasWidth = container.clientWidth;
            let canvasHeight = canvasWidth / targetRatio;
            if(canvasHeight > container.clientHeight){
                canvasHeight = container.clientHeight;
                canvasWidth = canvasHeight * targetRatio;
            }

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            ctx.fillStyle = framingState.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const imgRatio = img.width / img.height;

            if (framingState.mode === 'fit') {
                let w, h;
                if (imgRatio > targetRatio) { w = canvas.width; h = w / imgRatio; } 
                else { h = canvas.height; w = h * imgRatio; }
                ctx.drawImage(img, (canvas.width - w) / 2, (canvas.height - h) / 2, w, h);
            } else { // Fill mode
                let dstW, dstH;
                if (imgRatio > targetRatio) { dstH = canvas.height; dstW = dstH * imgRatio; } 
                else { dstW = canvas.width; dstH = dstW / imgRatio; }
                dstW *= framingState.zoom; dstH *= framingState.zoom;
                
                const minX = canvas.width - dstW; const minY = canvas.height - dstH;
                framingState.offsetX = Math.max(minX, Math.min(0, framingState.offsetX));
                framingState.offsetY = Math.max(minY, Math.min(0, framingState.offsetY));
                
                ctx.drawImage(img, framingState.offsetX, framingState.offsetY, dstW, dstH);
            }
        }

        function activateEyedropper() {
            if (!window.EyeDropper) { alert('Your browser does not support the Eyedropper API.'); return; }
            const eyeDropper = new EyeDropper();
            eyeDropper.open()
                .then(result => {
                    bgColorPicker.value = result.sRGBHex;
                    framingState.bgColor = result.sRGBHex;
                    drawFramingCanvas();
                })
                .catch(e => console.log('Eyedropper canceled.'));
        }

        async function applyFraming() {
            const state = upscaledCanvases.get(framingState.cardId);
            const finalCanvas = state.canvas; 
            const finalCtx = finalCanvas.getContext('2d');
            const tempFramingCanvas = document.getElementById('framing-canvas');
            
            const newImg = await new Promise(resolve => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.src = tempFramingCanvas.toDataURL();
            });

            state.originalImage = newImg;
            state.rotation = 0;
            state.brightness = 0;
            state.sharpness = 0;
            
            const card = document.getElementById(framingState.cardId);
            card.querySelector('.brightness-slider').value = 0;
            card.querySelector('.sharpen-slider').value = 0;
            card.querySelector('.rotate-icon').style.transform = `rotate(0deg)`;

            finalCanvas.width = newImg.width;
            finalCanvas.height = newImg.height;
            redrawCanvas(framingState.cardId);

            framingModal.classList.add('hidden');
        }

        function handleBeforeClick(cardId) {
            if (afterImageId === cardId) afterImageId = null;
            beforeImageId = cardId;
            updateComparisonSelectionUI();
            triggerComparisonCheck();
        }

        function handleAfterClick(cardId) {
            if (beforeImageId === cardId) beforeImageId = null;
            afterImageId = cardId;
            updateComparisonSelectionUI();
            triggerComparisonCheck();
        }

        function updateComparisonSelectionUI() {
            document.querySelectorAll('.bg-gray-800[id^="card-"]').forEach(card => {
                const beforeBtn = card.querySelector('.before-btn');
                const afterBtn = card.querySelector('.after-btn');
                if (beforeBtn && afterBtn) {
                    beforeBtn.classList.remove('btn-compare-active');
                    afterBtn.classList.remove('btn-compare-active');
                    card.style.boxShadow = '';
                    if (card.id === beforeImageId) {
                        beforeBtn.classList.add('btn-compare-active');
                        card.style.boxShadow = '0 0 0 3px #9333ea';
                    }
                    if (card.id === afterImageId) {
                        afterBtn.classList.add('btn-compare-active');
                        card.style.boxShadow = '0 0 0 3px #0d9488';
                    }
                }
            });
        }

        function triggerComparisonCheck() { if (beforeImageId && afterImageId) generateComparison(); }

        function resetComparisonSelection() {
            beforeImageId = null; afterImageId = null; comparisonBlob = null;
            updateComparisonSelectionUI();
        }
        
        function generateComparison() {
            if (!beforeImageId || !afterImageId) return;
            comparisonBlob = null;
            const state1 = upscaledCanvases.get(beforeImageId), state2 = upscaledCanvases.get(afterImageId);
            const canvas1 = state1.canvas, canvas2 = state2.canvas;
            
            const targetHeight = Math.min(canvas1.height, canvas2.height, 600);
            const newWidth1 = canvas1.width * (targetHeight / canvas1.height);
            const newWidth2 = canvas2.width * (targetHeight / canvas2.height);

            const totalWidth = newWidth1 + newWidth2 + 40;
            const comparisonCanvas = document.createElement('canvas');
            comparisonCanvas.width = totalWidth; comparisonCanvas.height = targetHeight + 80;
            const ctx = comparisonCanvas.getContext('2d');
            ctx.fillStyle = '#1f2937'; ctx.fillRect(0, 0, totalWidth, comparisonCanvas.height);
            ctx.font = 'bold 24px Inter, sans-serif'; ctx.fillStyle = 'white'; ctx.textAlign = 'center';
            
            ctx.fillText('Before', newWidth1 / 2, 35);
            ctx.drawImage(canvas1, 0, 60, newWidth1, targetHeight);
            
            ctx.fillText('After', newWidth1 + 40 + (newWidth2 / 2), 35);
            ctx.drawImage(canvas2, newWidth1 + 40, 60, newWidth2, targetHeight);
            
            comparisonCanvasContainer.innerHTML = '';
            comparisonCanvas.className = 'max-w-full h-auto mx-auto rounded-md';
            comparisonCanvasContainer.appendChild(comparisonCanvas);
            
            comparisonCanvas.toBlob(blob => {
                comparisonBlob = blob;
                comparisonModal.classList.remove('hidden');
            }, 'image/jpeg', 0.95);
        }

        async function downloadComparisonImage() {
            if (comparisonBlob) {
                let finalBlob = comparisonBlob;
                if (finalBlob.size < MIN_SIZE_BYTES) {
                    const tempImg = new Image();
                    await new Promise(resolve => {
                        tempImg.onload = resolve;
                        tempImg.src = URL.createObjectURL(comparisonBlob);
                    });
                    
                    const tempState = { originalImage: tempImg, rotation: 0, brightness: 0, sharpness: 0, canvas: document.createElement('canvas') };
                    tempState.canvas.width = tempImg.width;
                    tempState.canvas.height = tempImg.height;

                    const tempId = 'comparison-temp';
                    upscaledCanvases.set(tempId, tempState);
                    const result = await getSizedBlob(tempId, 'jpeg');
                    upscaledCanvases.delete(tempId);
                    finalBlob = result.blob;
                }
                saveAs(finalBlob, 'image_comparison.jpeg');
                comparisonModal.classList.add('hidden');
                resetComparisonSelection();
            }
        }

        async function downloadAllAsZip() {
            if (upscaledCanvases.size === 0) return;
            downloadAllBtn.disabled = true; downloadAllBtn.innerHTML = 'Sizing & Zipping...';
            
            const spid = spidInput.value.trim();
            const zip = new JSZip();
            
            try {
                for (const [cardId, state] of upscaledCanvases.entries()) {
                    const { blob, width, height } = await getSizedBlob(cardId, 'jpeg');
                    const scaleFactor = (state.rotation === 0 || state.rotation === 180) ? width / state.originalImage.width : width / state.originalImage.height;
                    const baseFileName = state.fileName.split('.').slice(0, -1).join('.') || state.fileName;
                    const finalFileName = `${spid ? spid + '_' : ''}upscaled_${scaleFactor.toFixed(1)}x_${baseFileName}.jpeg`;
                    
                    const report = diagnostics.imageReports.find(r => r && r.fileName === state.fileName);
                    if (report) { report.upscaledSize = `${(blob.size / 1024).toFixed(2)} KB`; report.rawUpscaledSize = blob.size; }
                    
                    zip.file(finalFileName, blob);
                }
                const content = await zip.generateAsync({ type: 'blob' });
                saveAs(content, 'upscaled_images.zip');
            } catch (error) { 
                console.error("Error creating zip file:", error); 
                downloadAllBtn.textContent = 'Error!';
                setTimeout(() => { downloadAllBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>Download All as Zip`; }, 2000);
            } finally {
                if (!downloadAllBtn.textContent.includes('Error')) {
                   downloadAllBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>Download All as Zip`;
                }
                downloadAllBtn.disabled = false;
            }
        }

        copyDiagnosticsBtn.addEventListener('click', () => {
            if (diagnostics.timeSpentOnPreviewsStart) diagnostics.timeSpentOnPreviews = `${(Date.now() - diagnostics.timeSpentOnPreviewsStart) / 1000} seconds`;
            
            const validReports = diagnostics.imageReports.filter(Boolean);
            diagnostics.totalProcessingTime = `${(validReports.reduce((acc, report) => acc + (parseInt(report.processingTime) || 0), 0) / 1000).toFixed(3)} seconds`;
            diagnostics.totalUpscaledOutputSize = `${(validReports.reduce((acc, report) => acc + (report.rawUpscaledSize || 0), 0) / 1024).toFixed(2)} KB`;

            let reportString = `--- DIAGNOSTIC REPORT ---\n\n`;
            
            reportString += `## SESSION METRICS\n`;
            ['appVersion', 'sessionId', 'pageLoadTimestamp', 'sessionDuration', 'browserInfo', 'screenResolution'].forEach(key => reportString += `${key}: ${diagnostics[key]}\n`);
            
            reportString += `\n## USER INTERACTION METRICS\n`;
            ['timeToFirstUpload', 'uploadMethod', 'timeFromUploadToProcess', 'scaleChanges', 'mostUsedScaleFactor', 'individualDownloads', 'downloadAllClicked', 'scrollDepth', 'timeSpentOnPreviews', 'sessionAbandoned'].forEach(key => reportString += `${key}: ${diagnostics[key]}\n`);

            reportString += `\n## OVERALL PROCESSING METRICS\n`;
            ['totalProcessingTime', 'totalUpscaledOutputSize', 'processingErrors'].forEach(key => reportString += `${key}: ${Array.isArray(diagnostics[key]) ? diagnostics[key].join(', ') || 'None' : diagnostics[key]}\n`);
            
            reportString += `\n## EDIT ACTIONS (${diagnostics.editActions.length})\n` + diagnostics.editActions.map(a => `${a.action}: ${a.value} on ${a.file}`).join('\n');

            reportString += `\n\n## INDIVIDUAL IMAGE REPORTS (${validReports.length})\n`;
            validReports.forEach((report, index) => {
                reportString += `----------------------------------------\nIMAGE ${index + 1}:\n` + Object.entries(report).filter(([k]) => k !== 'index').map(([k, v]) => `  ${k}: ${v}`).join('\n') + '\n';
            });
            
            const tempTextarea = document.createElement('textarea');
            tempTextarea.value = reportString;
            tempTextarea.style.position = 'fixed'; 
            tempTextarea.style.opacity = 0;
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            try {
                document.execCommand('copy');
                copyDiagnosticsBtn.textContent = 'Copied!';
            } catch (err) {
                console.error('Failed to copy diagnostics:', err);
                copyDiagnosticsBtn.textContent = 'Copy Failed!';
            }
            document.body.removeChild(tempTextarea);
            setTimeout(() => { copyDiagnosticsBtn.textContent = 'Copy Diagnostic Info'; }, 2000);
        });
    </script>
</body>
</html>

