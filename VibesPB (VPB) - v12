<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibesPB (VPB)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        #gameCanvas {
            border: 2px solid #00ff00;
            background-color: #000;
            border-radius: 8px;
            box-shadow: 0 0 10px #00ff00;
        }
        .game-info-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 480px;
            margin-bottom: 15px;
        }
        .game-info {
            font-size: 1.2em;
            padding: 5px 10px;
            border: 1px solid #00ff00;
            border-radius: 8px;
            background-color: #111;
            text-align: center;
            width: 45%;
        }
        .message-area {
            margin-top: 15px;
            font-size: 1.5em;
            text-align: center;
            height: 30px; 
        }
        button {
            background-color: #005000;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        button:hover {
            background-color: #007000;
            box-shadow: 0 0 8px #00ff00;
        }
        #logContainer {
            width: 100%;
            max-width: 480px; 
            margin-top: 10px;
        }
        #gameLogOutput {
            width: 100%;
            height: 200px;
            background-color: #222;
            color: #00dd00; 
            border: 1px solid #00ff00;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.8em;
            padding: 5px;
            box-sizing: border-box;
            border-radius: 4px;
            white-space: pre-wrap; 
            overflow-y: scroll; 
        }
    </style>
</head>
<body class="bg-gray-900 text-green-400 flex flex-col items-center justify-center min-h-screen p-5">

    <h1 class="text-4xl font-bold mb-5 text-center">[ VIBES PB ]</h1>

    <div class="game-info-container">
        <div id="playerScoreDisplay" class="game-info">Player: 0</div>
        <div id="aiScoreDisplay" class="game-info">AI: 0</div>
    </div>

    <canvas id="gameCanvas" width="480" height="420"></canvas> 
    <div id="messageArea" class="message-area"></div>
    <button id="startButton" class="mt-4">Start/Restart (R)</button>
    <button id="copyLogButton" class="mt-2">Copy Log & Pause</button> 
    <div id="logContainer" style="display: none;">
        <textarea id="gameLogOutput" readonly></textarea>
    </div>

    <script>
        const GAME_VERSION = "v12.0"; // Game version for logging
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const playerScoreDisplay = document.getElementById('playerScoreDisplay');
        const aiScoreDisplay = document.getElementById('aiScoreDisplay');
        const messageArea = document.getElementById('messageArea');
        const copyLogButton = document.getElementById('copyLogButton'); 
        const logContainer = document.getElementById('logContainer');     
        const gameLogOutput = document.getElementById('gameLogOutput');   

        // --- Paddle Constants ---
        const PADDLE_WIDTH = 70;  
        const PADDLE_ARM_WIDTH_ORIGINAL = 10; 
        const PADDLE_CATCH_SPOT_WIDTH = PADDLE_WIDTH - 2 * PADDLE_ARM_WIDTH_ORIGINAL;
        const PADDLE_BASE_HEIGHT = 8; 
        const PADDLE_ARM_HEIGHT_ORIGINAL = 12; 
        const PADDLE_ARM_HEIGHT_EXTENDED = PADDLE_ARM_HEIGHT_ORIGINAL * 1.06; // Arms 6% longer
        const PADDLE_TOTAL_HEIGHT = PADDLE_BASE_HEIGHT + PADDLE_ARM_HEIGHT_EXTENDED;
        const PADDLE_CATCH_DEPTH = PADDLE_ARM_HEIGHT_EXTENDED; 

        // --- Ball Constants ---
        const BALL_RADIUS = 7;   
        const BASE_BALL_SPEED_MAGNITUDE = 3.0; 
        const SUPERCHARGED_SPEED_MULTIPLIER = 2.0; // Double speed
        const SPECIAL_BRICK_SPEED_BOOST_FACTOR = 1.25;
        const SPECIAL_BRICK_BOOST_DURATION = 180; // 3 seconds at 60fps
        const MAX_BALL_SPEED_COMPONENT = 10; 

        // --- Gameplay Constants ---
        const WINNING_SCORE = 15;
        const MAX_BALLS_PER_SIDE = 1; 
        const RALLY_HIT_THRESHOLD_FOR_SPEEDUP = 4; 
        const RALLY_SPEEDUP_FACTOR = 1.05; 
        const PLAYER_PADDLE_BASE_SPEED = (6 * 1.08); 
        let currentPlayerPaddleMoveSpeed = PLAYER_PADDLE_BASE_SPEED * 1.05; // +5% faster by default


        // --- Player Paddle State ---
        let playerPaddleX = (canvas.width - PADDLE_WIDTH) / 2;
        const PLAYER_PADDLE_Y = canvas.height - PADDLE_TOTAL_HEIGHT - 10; 
        let leftArrowPressed = false;
        let rightArrowPressed = false;
        let spacebarDown = false; 
        let playerWantsToCatch = false; 
        let playerHeldBall = null;

        // --- AI Paddle State ---
        let aiPaddleX = (canvas.width - PADDLE_WIDTH) / 2;
        const AI_PADDLE_Y = 10; 
        let aiTargetX = aiPaddleX; 
        const AI_SMOOTHING_FACTOR = 0.07; 
        const AI_PREDICTION_FRAMES_SIMPLE = 10; 
        const AI_PADDLE_BASE_SPEED = 3.0; 
        let currentAiPaddleMoveSpeed = AI_PADDLE_BASE_SPEED;
        let aiWantsToCatch = false;
        let aiHeldBall = null;
        const AI_CATCH_CHANCE = 0.4; 
        const AI_SHOOT_DELAY_FRAMES = 35; 
        let aiShootTimer = 0;

        // --- Balls ---
        let playerBalls = []; 
        let aiBalls = [];     
        
        // --- Bricks ---
        const BRICK_ROW_COUNT = 4; 
        const BRICK_COLUMN_COUNT = 7;
        const BRICK_WIDTH = 55;
        const BRICK_HEIGHT = 15;
        const BRICK_PADDING = 5;
        let brickOffsetTop; 
        const BRICK_OFFSET_LEFT = 30;
        
        // --- Colors ---
        const PLAYER_PADDLE_ARM_COLOR = '#00BCD4'; // Cyan
        const PLAYER_PADDLE_CATCH_COLOR = '#B2EBF2'; // Light Cyan
        const PLAYER_PADDLE_CATCH_ACTIVE_COLOR = '#E91E63'; // Bright Pink
        const AI_PADDLE_ARM_COLOR = '#FF5722'; // Deep Orange
        const AI_PADDLE_CATCH_COLOR = '#FFCCBC'; // Light Orange/Pink
        const AI_PADDLE_CATCH_ACTIVE_COLOR = '#2196F3'; // Bright Blue

        const BRICK_COLORS = ["#D32F2F", "#F57C00", "#FBC02D", "#388E3C"];
        const SPECIAL_BRICK_COLOR = "#673AB7"; 

        let bricks = [];
        let playerScore = 0;
        let aiScore = 0;
        let gameRunning = false;
        let gamePaused = false; 
        let animationFrameId;
        let gameLogHistory = []; 
        let gameStartTime = 0; 
        let lastFrameTime = 0;
        let frameCountForDeltaLog = 0;
        let totalFramesRendered = 0;
        let lastPlayerPaddleXLog = playerPaddleX; 
        let lastAiPaddleXLog = aiPaddleX;

        const brickPatterns = [
            { name: "Full Wall", layout: null },
            { name: "Pyramid", layout: [
                [0,0,0,1,0,0,0], [0,0,1,1,1,0,0], [0,1,1,1,1,1,0], [1,1,1,1,1,1,1] ]},
            { name: "Alternating Columns", layout: [
                [1,0,1,0,1,0,1], [1,0,1,0,1,0,1], [1,0,1,0,1,0,1], [1,0,1,0,1,0,1] ]},
            { name: "Hollow Center", layout: [
                [1,1,1,1,1,1,1], [1,0,0,0,0,0,1], [1,0,0,0,0,0,1], [1,1,1,1,1,1,1] ]},
            { name: "Sparse", layout: [
                [1,0,0,1,0,0,1], [0,1,0,0,0,1,0], [0,0,1,0,1,0,0], [1,0,0,1,0,0,1] ]},
            { name: "Double Line", layout: [
                [1,1,1,1,1,1,1], [0,0,0,0,0,0,0], [0,0,0,0,0,0,0], [1,1,1,1,1,1,1] ]}
        ];
        let currentBrickPatternName = "Full Wall";

        // --- Logging Function ---
        function logGameData(message, data = {}) {
            const timestamp = new Date().toLocaleTimeString();
            const roundedData = {};
            // Iterate over the properties of the data object to round numbers
            for (const key in data) {
                const value = data[key];
                if (typeof value === 'number' && !Number.isInteger(value)) { // Round only floating point numbers
                    roundedData[key] = parseFloat(value.toFixed(3)); // Increased precision for floats
                } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) { // Handle nested objects (like pos, speed)
                    roundedData[key] = {}; // Initialize if not already an object
                    for (const subKey in value) {
                        if (typeof value[subKey] === 'number' && !Number.isInteger(value[subKey])) {
                            roundedData[key][subKey] = parseFloat(value[subKey].toFixed(3));
                        } else if (typeof value[subKey] === 'object' && value[subKey] !== null && !Array.isArray(value[subKey])) {
                             // Handle one more level of nesting if necessary (e.g. for complex states)
                            roundedData[key][subKey] = {};
                            for (const deepKey in value[subKey]) {
                                if (typeof value[subKey][deepKey] === 'number' && !Number.isInteger(value[subKey][deepKey])) {
                                    roundedData[key][subKey][deepKey] = parseFloat(value[subKey][deepKey].toFixed(3));
                                } else {
                                     roundedData[key][subKey][deepKey] = value[subKey][deepKey];
                                }
                            }
                        }
                        else {
                            roundedData[key][subKey] = value[subKey]; // Assign non-numeric or integer properties directly
                        }
                    }
                } else { 
                    roundedData[key] = value; // Assign non-object, non-float properties directly
                }
            }
            // Construct and output the log entry
            const logEntry = `[VPB ${GAME_VERSION} LOG - ${timestamp}] ${message} ${Object.keys(roundedData).length > 0 ? JSON.stringify(roundedData) : ''}`;
            console.log(logEntry); 
            gameLogHistory.push(logEntry);
            // Update the on-screen log display if it's visible
            if (logContainer.style.display !== 'none') { 
                gameLogOutput.value = gameLogHistory.join('\n');
                gameLogOutput.scrollTop = gameLogOutput.scrollHeight; // Auto-scroll to the latest log
            }
        }
        
        // --- UI Event Handlers ---
        let wasPausedByLogButton = false; // Track if pause was initiated by the log button
        copyLogButton.addEventListener('click', () => {
            // Determine if the game was running and not paused by other means (like 'S' key)
            if (gameRunning && !gamePaused) { 
                gamePaused = true; // Pause the game
                wasPausedByLogButton = true; // Mark that this button caused the pause
                logGameData("Game Paused (Copy Log Button Action)");
                displayMessage("Log Copied! Game Paused ('S' to Resume).");
                copyLogButton.textContent = 'Hide Log & Resume';
            } else if (gamePaused && wasPausedByLogButton) { // If resuming a game paused by this button
                gamePaused = false;
                wasPausedByLogButton = false;
                logContainer.style.display = 'none'; // Hide the log
                copyLogButton.textContent = 'Copy Log & Pause'; // Revert button text
                displayMessage(""); 
                logGameData("Game Resumed (Log Button Action)");
                lastFrameTime = Date.now(); // Reset frame time to prevent large delta
                animationFrameId = requestAnimationFrame(gameLoop); // Restart game loop
                return; // Exit early, don't proceed to copy
            } else if (gamePaused && !wasPausedByLogButton) { // If game was already paused by 'S' key
                 displayMessage("PAUSED - Log Copied");
                 copyLogButton.textContent = 'Hide Log & Resume'; // Allow this button to also resume
            }

            // Prepare and copy log content
            gameLogOutput.value = gameLogHistory.join('\n');
            logContainer.style.display = 'block'; // Ensure log area is visible
            gameLogOutput.select(); // Select all text in the textarea
            gameLogOutput.setSelectionRange(0, gameLogOutput.value.length); // For broader browser compatibility
            try {
                const successful = document.execCommand('copy'); // Attempt to copy
                if (!successful) { // Fallback for browsers where execCommand might fail (e.g., in some iframe contexts)
                     navigator.clipboard.writeText(gameLogOutput.value).then(() => {
                        logGameData("Log Copied to Clipboard (Fallback)!");
                     }).catch(err => {
                        logGameData("Copying failed (Fallback)", { error: err.message });
                        displayMessage('Copying failed. Please copy manually.');
                     });
                } else {
                    logGameData("Log Copied to Clipboard!");
                }
                // Update message if game was not running or already paused by 'S'
                if (!gamePaused && gameRunning) { // If it was running and just got paused by this button
                     displayMessage("Log Copied! Game Paused.");
                } else if (!gameRunning || playerScore >= WINNING_SCORE || aiScore >= WINNING_SCORE) {
                    displayMessage("Final Log Copied!");
                }

            } catch (err) {
                displayMessage('Error copying. Game Paused.');
                logGameData("Error copying log", { error: err.message });
            }
            // Adjust button text if game is over
             if (!gameRunning || playerScore >= WINNING_SCORE || aiScore >= WINNING_SCORE) {
                copyLogButton.textContent = 'Copy Final Log'; 
                // gamePaused = false; // Game is over, cannot be "resumed" in the typical sense by this button
            }
        });

        // --- Brick Initialization ---
        function calculateBrickOffsetTop() {
            const totalBrickWallHeight = BRICK_ROW_COUNT * (BRICK_HEIGHT + BRICK_PADDING) - BRICK_PADDING;
            brickOffsetTop = (canvas.height - totalBrickWallHeight) / 2;
        }

        function initBricks() {
            calculateBrickOffsetTop();
            bricks = [];
            let activeBrickCount = 0;
            const patternIndex = Math.floor(Math.random() * brickPatterns.length);
            const selectedPattern = brickPatterns[patternIndex];
            currentBrickPatternName = selectedPattern.name;
            
            let specialBricksToPlace = Math.floor(BRICK_ROW_COUNT * BRICK_COLUMN_COUNT * 0.1); // Target ~10% special bricks

            for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                bricks[c] = [];
                for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                    let status = 1;
                    if (selectedPattern.layout) { // Apply predefined layout if one exists
                        status = selectedPattern.layout[r] && selectedPattern.layout[r][c] ? 1 : 0;
                    }
                    
                    let isSpecial = false;
                    let brickColor = BRICK_COLORS[r % BRICK_COLORS.length]; // Cycle through normal colors
                    let brickType = 'normal';

                    if (status === 1 && specialBricksToPlace > 0 && Math.random() < 0.25) { // 25% chance for an active brick to be special
                        isSpecial = true;
                        brickColor = SPECIAL_BRICK_COLOR;
                        brickType = 'speed_boost'; // Currently only one type of special brick
                        specialBricksToPlace--;
                    }

                    bricks[c][r] = { 
                        x: (c * (BRICK_WIDTH + BRICK_PADDING)) + BRICK_OFFSET_LEFT, 
                        y: (r * (BRICK_HEIGHT + BRICK_PADDING)) + brickOffsetTop, 
                        status: status, 
                        color: brickColor, 
                        isSpecial: isSpecial,
                        type: brickType,
                        col: c, 
                        row: r 
                    };
                    if (status === 1) activeBrickCount++;
                }
            }
            logGameData("Bricks Initialized", { pattern: currentBrickPatternName, activeBrickCount, initialSpecialBricksPlaced: Math.floor(BRICK_ROW_COUNT * BRICK_COLUMN_COUNT * 0.1) - specialBricksToPlace });
        }
        
        // --- Ball Spawning and Launching ---
        function launchBall(ball, type, isSupercharged = false) {
            const paddleX = (type === 'player') ? playerPaddleX : aiPaddleX;
            const paddleY = (type === 'player') ? PLAYER_PADDLE_Y : AI_PADDLE_Y;

            ball.x = paddleX + PADDLE_WIDTH / 2;
            ball.isSupercharged = isSupercharged;
            ball.rallyHitCount = 0;
            ball.isBoosted = false; 
            ball.speedBoostTimer = 0; 

            const speedMagnitude = isSupercharged ? BASE_BALL_SPEED_MAGNITUDE * SUPERCHARGED_SPEED_MULTIPLIER : BASE_BALL_SPEED_MAGNITUDE;
            
            let initialSpeedX = (Math.random() * 1.5 + speedMagnitude - 0.75) * (Math.random() > 0.5 ? 1 : -1) ; 
            let initialSpeedY = (Math.random() * 1.0 + speedMagnitude - 0.5);

            // Ensure minimum speed to prevent overly slow/stuck balls
            if (Math.abs(initialSpeedX) < 1.0) initialSpeedX = Math.sign(initialSpeedX || 1) * 1.0;
            if (Math.abs(initialSpeedY) < 1.0) initialSpeedY = Math.sign(initialSpeedY || 1) * 1.0;


            if (type === 'player') {
                ball.y = paddleY + PADDLE_ARM_HEIGHT_EXTENDED + PADDLE_BASE_HEIGHT / 2 - BALL_RADIUS - 1; // Launch from inside U base
                ball.speedX = initialSpeedX * (isSupercharged ? SUPERCHARGED_SPEED_MULTIPLIER : 1);
                ball.speedY = -initialSpeedY * (isSupercharged ? SUPERCHARGED_SPEED_MULTIPLIER : 1); // Upwards
            } else { // AI
                ball.y = AI_PADDLE_Y + PADDLE_BASE_HEIGHT / 2 + BALL_RADIUS + 1; // Launch from inside U base
                ball.speedX = initialSpeedX * (isSupercharged ? SUPERCHARGED_SPEED_MULTIPLIER : 1);
                ball.speedY = initialSpeedY * (isSupercharged ? SUPERCHARGED_SPEED_MULTIPLIER : 1); // Downwards
            }
             logGameData(`${type.toUpperCase()} Ball Launched`, { 
                supercharged: isSupercharged, 
                pos: {x: ball.x, y: ball.y}, 
                speed: {x: ball.speedX, y: ball.speedY},
                heldBallBeforeLaunch: (type === 'player' ? playerHeldBall : aiHeldBall) ? true : false // Log if it was from a held state
            });
        }

        function spawnNewBall(type, reason = "initial") {
            const ballArray = (type === 'player') ? playerBalls : aiBalls;
            // Check if max balls already in play for this side
            if (ballArray.length >= MAX_BALLS_PER_SIDE) {
                logGameData(`Spawn ${type} ball (${reason}) SKIPPED: max balls (${MAX_BALLS_PER_SIDE}) reached.`, {currentBalls: ballArray.length});
                return;
            }
            // Prevent spawn if a ball is already held by that side
            if (type === 'player' && playerHeldBall) {
                logGameData(`Spawn ${type} ball (${reason}) SKIPPED: ball already held by player.`, {currentBalls: ballArray.length});
                return;
            }
            if (type === 'ai' && aiHeldBall) {
                logGameData(`Spawn ${type} ball (${reason}) SKIPPED: ball already held by AI.`, {currentBalls: ballArray.length});
                return;
            }

            let newBall = {};
            launchBall(newBall, type, false); // New balls are not initially supercharged
            ballArray.push(newBall);

            logGameData(`${type.toUpperCase()} ball SPARKED (Total Active: ${ballArray.length})`, { 
                reason: reason,
                newBallPos: {x: newBall.x, y: newBall.y},
                newBallSpeed: {x: newBall.speedX, y: newBall.speedY}
            });
        }

        // --- Input Handling ---
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
             if (!gameRunning && key !== 'r') { 
                 if (key !== 's') return; // Only allow R to start if game not running. S for pause only if running.
            }

            if (key === 'arrowleft' || key === 'a') {
                if (!leftArrowPressed) logGameData("Input: Left Arrow Down", {playerPaddleX});
                leftArrowPressed = true;
            } else if (key === 'arrowright' || key === 'd') {
                if (!rightArrowPressed) logGameData("Input: Right Arrow Down", {playerPaddleX});
                rightArrowPressed = true;
            } else if (key === ' ') { // Spacebar for Catch/Shoot
                e.preventDefault(); 
                if (!spacebarDown) { // First press
                    spacebarDown = true;
                    if (gameRunning && !gamePaused) { 
                        if (playerHeldBall) { 
                            logGameData("Input: Spacebar Pressed (Player SHOOT action)", {ballCurrentPos: playerHeldBall.pos}); // Log current pos before launch
                            launchBall(playerHeldBall, 'player', true); 
                            playerBalls.push(playerHeldBall);
                            playerHeldBall = null;
                            // playerWantsToCatch = false; // Reset on keyup
                        } else { 
                            logGameData("Input: Spacebar Pressed (Player primes CATCH)");
                            playerWantsToCatch = true; 
                        }
                    }
                }
            } else if (key === 's') { // 'S' key for Pause/Resume
                 e.preventDefault();
                 if (gameRunning && (playerScore < WINNING_SCORE && aiScore < WINNING_SCORE)) { 
                    gamePaused = !gamePaused;
                    wasPausedByLogButton = false; 
                    if (gamePaused) {
                        displayMessage("PAUSED ('S' to Resume)");
                        logGameData("Game Paused ('S' key)");
                        copyLogButton.textContent = 'Hide Log & Resume'; 
                    } else {
                        displayMessage(""); 
                        logGameData("Game Resumed ('S' key)");
                        copyLogButton.textContent = 'Copy Log & Pause'; 
                        lastFrameTime = performance.now(); // Use performance.now for consistency
                        animationFrameId = requestAnimationFrame(gameLoop); 
                    }
                }
            } else if (key === 'r') { 
                e.preventDefault();
                logGameData("Input: 'R' Key Pressed - Restarting/Starting Game");
                startGame();
            }
        });
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'arrowleft' || key === 'a') {
                if (leftArrowPressed) logGameData("Input: Left Arrow Up", {playerPaddleX});
                leftArrowPressed = false;
            } else if (key === 'arrowright' || key === 'd') {
                if (rightArrowPressed) logGameData("Input: Right Arrow Up", {playerPaddleX});
                rightArrowPressed = false;
            } else if (key === ' ') { 
                if (spacebarDown) logGameData("Input: Spacebar Up (Catch prime released if no catch action taken)");
                spacebarDown = false;
                playerWantsToCatch = false; // Reset catch prime on key release
            }
        });

        startButton.addEventListener('click', () => {
            logGameData("Start/Restart Button Clicked");
            startGame();
        });

        // --- Drawing Functions ---
        function drawPaddle(x, y, mainColor, catchColor, catchActiveColor, type, wantsCatch) {
            const baseH = PADDLE_BASE_HEIGHT;
            const armH = PADDLE_ARM_HEIGHT_EXTENDED;
            const armW = PADDLE_ARM_WIDTH_ORIGINAL; 
            const totalH = baseH + armH;
            const catchSpotActualWidth = PADDLE_WIDTH - 2 * armW;

            // Draw Arms
            ctx.fillStyle = mainColor;
            ctx.fillRect(x, (type === 'player' ? y : y + baseH), armW, armH); // Left Arm
            ctx.fillRect(x + PADDLE_WIDTH - armW, (type === 'player' ? y : y + baseH), armW, armH); // Right Arm
            
            // Draw Base / Catch Area
            ctx.fillStyle = wantsCatch ? catchActiveColor : catchColor;
            ctx.fillRect(x + armW, (type === 'player' ? y + armH : y), catchSpotActualWidth, baseH); // Base
        }


        function drawBall(ball) {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
            let ballColor = ball.isPlayerOriginBall ? '#FFF' : '#FFD700'; 
            if (ball.isSupercharged) ballColor = '#FF6347'; 
            else if (ball.isBoosted) ballColor = '#1E90FF'; 
            ctx.fillStyle = ballColor;
            ctx.fill();
            ctx.closePath();
            
            if (ball.isSupercharged) { 
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, BALL_RADIUS + 3, 0, Math.PI * 2);
                ctx.strokeStyle = '#FF4500'; 
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.5 + Math.random()*0.3; 
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            } else if (ball.isBoosted) {
                 ctx.beginPath();
                ctx.arc(ball.x, ball.y, BALL_RADIUS + 2, 0, Math.PI * 2);
                ctx.strokeStyle = '#87CEFA'; 
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5 + Math.random()*0.2; 
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }
        }

        function drawBricks() {
            for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                    if (bricks[c][r].status === 1) {
                        ctx.beginPath();
                        ctx.rect(bricks[c][r].x, bricks[c][r].y, BRICK_WIDTH, BRICK_HEIGHT);
                        ctx.fillStyle = bricks[c][r].color; 
                        ctx.fill();
                        if (bricks[c][r].isSpecial) { 
                            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                            ctx.font = 'bold 10px "Courier New"';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText("S+", bricks[c][r].x + BRICK_WIDTH/2, bricks[c][r].y + BRICK_HEIGHT/2 + 1);
                        }
                        ctx.closePath();
                    }
                }
            }
        }

        // --- Paddle Update Logic ---
        function updatePlayerPaddle() {
            const oldX = playerPaddleX;
            // Adjust speed based on whether catch is active (spacebar held)
            currentPlayerPaddleMoveSpeed = playerWantsToCatch ? (PLAYER_PADDLE_BASE_SPEED * 1.05 * 0.97) : (PLAYER_PADDLE_BASE_SPEED * 1.05);

            if (leftArrowPressed && playerPaddleX > 0) {
                playerPaddleX -= currentPlayerPaddleMoveSpeed;
            }
            if (rightArrowPressed && playerPaddleX + PADDLE_WIDTH < canvas.width) {
                playerPaddleX += currentPlayerPaddleMoveSpeed;
            }
            if (playerPaddleX < 0) playerPaddleX = 0;
            if (playerPaddleX + PADDLE_WIDTH > canvas.width) playerPaddleX = canvas.width - PADDLE_WIDTH;
            
            if (Math.abs(oldX - playerPaddleX) > 0.01) { 
                logGameData("Player Paddle Moved", { newX: playerPaddleX, dx: playerPaddleX - oldX, speedUsed: currentPlayerPaddleMoveSpeed, wantsCatch: playerWantsToCatch });
            }
            // Update held ball position if any
            if (playerHeldBall) {
                playerHeldBall.x = playerPaddleX + PADDLE_WIDTH / 2;
                playerHeldBall.y = PLAYER_PADDLE_Y + PADDLE_ARM_HEIGHT_EXTENDED + PADDLE_BASE_HEIGHT / 2; // Centered in U base
                playerHeldBall.speedX = 0; playerHeldBall.speedY = 0; 
            }
        }

        function updateAiPaddle() {
            const oldX = aiPaddleX;
            let targetBallToTrack = null;
            currentAiPaddleMoveSpeed = aiWantsToCatch ? (AI_PADDLE_BASE_SPEED * 0.97) : AI_PADDLE_BASE_SPEED;

            if (aiHeldBall) {
                // AI logic for holding/aiming before shoot (e.g., aim towards player or an opening)
                // For now, just stay relatively still or make small adjustments
                aiTargetX = aiPaddleX; // Simple: try to stay put while aiming
            } else if (aiBalls.length > 0 && aiBalls[0]) { 
                targetBallToTrack = aiBalls[0];
            } else if (playerBalls.length > 0 && playerBalls[0] && playerBalls[0].y < canvas.height * 0.6) { 
                targetBallToTrack = playerBalls[0];
            }

            if (targetBallToTrack && !aiHeldBall) { // Only track if not holding a ball
                const anticipatedBallX = targetBallToTrack.x + targetBallToTrack.speedX * AI_PREDICTION_FRAMES_SIMPLE;
                let desiredPaddleCenterX = anticipatedBallX;
                
                aiTargetX = aiTargetX * (1 - AI_SMOOTHING_FACTOR) + (desiredPaddleCenterX - PADDLE_WIDTH / 2) * AI_SMOOTHING_FACTOR;

                if (Math.abs(aiPaddleX - aiTargetX) > currentAiPaddleMoveSpeed * 0.25) { // Reduced threshold for movement
                    if (aiPaddleX < aiTargetX) {
                        aiPaddleX += Math.min(currentAiPaddleMoveSpeed, aiTargetX - aiPaddleX);
                    } else if (aiPaddleX > aiTargetX) {
                        aiPaddleX -= Math.min(currentAiPaddleMoveSpeed, aiPaddleX - aiTargetX);
                    }
                }
            }
            
            if (aiPaddleX < 0) aiPaddleX = 0;
            if (aiPaddleX + PADDLE_WIDTH > canvas.width) aiPaddleX = canvas.width - PADDLE_WIDTH;
            
            if (Math.abs(oldX - aiPaddleX) > 0.01) {
                 logGameData("AI Paddle Moved", { newX: aiPaddleX, dx: aiPaddleX - oldX, trackingBallX: targetBallToTrack ? targetBallToTrack.x : null, aiTargetCalcX: aiTargetX + PADDLE_WIDTH/2, speedUsed: currentAiPaddleMoveSpeed, wantsCatch: aiWantsToCatch });
            }

            // AI Catch Logic attempt
            if (!aiHeldBall && aiBalls.length > 0 && aiBalls[0] && !aiWantsToCatch) { 
                const ball = aiBalls[0];
                const paddleCenterX = aiPaddleX + PADDLE_WIDTH / 2;
                const inCatchZoneX = Math.abs(ball.x - paddleCenterX) < PADDLE_CATCH_SPOT_WIDTH * 0.35; 
                const approachingCorrectlyY = ball.speedY < 0 && ball.y < AI_PADDLE_Y + PADDLE_TOTAL_HEIGHT + BALL_RADIUS * 5 && ball.y > AI_PADDLE_Y + PADDLE_BASE_HEIGHT;

                if (approachingCorrectlyY && inCatchZoneX && Math.abs(ball.speedY) < BASE_BALL_SPEED_MAGNITUDE * 1.1 && Math.random() < AI_CATCH_CHANCE) {
                    aiWantsToCatch = true; 
                    logGameData("AI Decides to Attempt Catch", {ballPos: {x:ball.x, y:ball.y}, paddleX: aiPaddleX, ballSpeedY: ball.speedY});
                }
            }
            // AI Shoot Logic
            if (aiHeldBall) {
                aiHeldBall.x = aiPaddleX + PADDLE_WIDTH / 2;
                aiHeldBall.y = AI_PADDLE_Y + PADDLE_BASE_HEIGHT / 2; 
                aiHeldBall.speedX = 0; aiHeldBall.speedY = 0;
                aiShootTimer--;
                if (aiShootTimer <= 0) {
                    logGameData("AI Shooting Supercharged Ball", { paddleX: aiPaddleX, targetXForShot: playerPaddleX + PADDLE_WIDTH/2 }); // Simple aim at player center
                    launchBall(aiHeldBall, 'ai', true); 
                    aiBalls.push(aiHeldBall);
                    aiHeldBall = null;
                    aiWantsToCatch = false; // Reset after shooting
                }
            } else { 
                // aiWantsToCatch = false; // Reset if not holding and no immediate catch opportunity
            }
        }
        
        // --- Ball and Collision Logic ---
        function handleBallBrickCollision(ball, isPlayerOriginBall) {
            if (!ball) return; 
            let totalActiveBricks = 0; 
            for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                    if (bricks[c][r].status === 1) totalActiveBricks++;
                }
            }

            for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                    let b = bricks[c][r];
                    if (b.status === 1) {
                        if (ball.x + BALL_RADIUS > b.x && ball.x - BALL_RADIUS < b.x + BRICK_WIDTH &&
                            ball.y + BALL_RADIUS > b.y && ball.y - BALL_RADIUS < b.y + BRICK_HEIGHT) {
                            
                            const oldBallState = {pos: {x:ball.x, y:ball.y}, speed: {x: ball.speedX, y: ball.speedY}, supercharged: ball.isSupercharged, boosted: ball.isBoosted};
                            
                            if (ball.isSupercharged) { 
                                b.status = 0;
                                totalActiveBricks--;
                                logGameData("Supercharged Brick Break", {by: (isPlayerOriginBall ? 'Player' : 'AI'), brick: {c:b.col, r:b.row, type:b.type}, ballState: oldBallState, remainingBricks: totalActiveBricks});
                            } else {
                                const overlapX = (ball.x < b.x + BRICK_WIDTH/2) ? (ball.x + BALL_RADIUS - b.x) : (b.x + BRICK_WIDTH - (ball.x - BALL_RADIUS));
                                const overlapY = (ball.y < b.y + BRICK_HEIGHT/2) ? (ball.y + BALL_RADIUS - b.y) : (b.y + BRICK_HEIGHT - (ball.y - BALL_RADIUS));
                                if (overlapX < overlapY) { 
                                    ball.speedX = -ball.speedX;
                                } else { 
                                    ball.speedY = -ball.speedY;
                                }
                                b.status = 0;
                                totalActiveBricks--;
                                logGameData("Brick Broken", { 
                                    by: (isPlayerOriginBall ? 'Player' : 'AI'), 
                                    brick: {c: b.col, r: b.row, color: b.color, type: b.type},
                                    ballState: oldBallState,
                                    newBallSpeed: {x: ball.speedX, y: ball.speedY},
                                    remainingBricks: totalActiveBricks
                                });
                                if (b.isSpecial && b.type === 'speed_boost') {
                                    ball.isBoosted = true;
                                    ball.speedBoostTimer = SPECIAL_BRICK_BOOST_DURATION; 
                                    ball.speedX = Math.min(MAX_BALL_SPEED_COMPONENT, Math.max(-MAX_BALL_SPEED_COMPONENT, ball.speedX * SPECIAL_BRICK_SPEED_BOOST_FACTOR));
                                    ball.speedY = Math.min(MAX_BALL_SPEED_COMPONENT, Math.max(-MAX_BALL_SPEED_COMPONENT, ball.speedY * SPECIAL_BRICK_SPEED_BOOST_FACTOR));
                                    logGameData("Special Brick Hit: Ball Speed Boost Activated!", {ballOwner: (isPlayerOriginBall ? 'Player' : 'AI'), newSpeed: {x: ball.speedX, y: ball.speedY}});
                                }
                            }
                            if (totalActiveBricks === 0) {
                                logGameData("All Bricks Cleared!", {pattern: currentBrickPatternName});
                            }
                        }
                    }
                }
            }
        }

        function updateAndProcessBallArray(ballArray, isPlayerOriginBalls) {
            for (let i = ballArray.length - 1; i >= 0; i--) { 
                let ball = ballArray[i];
                if (!ball) continue; 
                
                const oldBallState = {pos: {x:ball.x, y:ball.y}, speed: {x: ball.speedX, y: ball.speedY}, supercharged: ball.isSupercharged, boosted: ball.isBoosted, rally: ball.rallyHitCount};

                if (ball.isBoosted && ball.speedBoostTimer > 0) {
                    ball.speedBoostTimer--;
                    if (ball.speedBoostTimer <= 0) {
                        ball.isBoosted = false;
                        ball.speedX /= SPECIAL_BRICK_SPEED_BOOST_FACTOR; 
                        ball.speedY /= SPECIAL_BRICK_SPEED_BOOST_FACTOR;
                        logGameData("Ball Speed Boost Ended", {ballOwner: (isPlayerOriginBalls ? 'Player' : 'AI'), revertedSpeed: {x: ball.speedX, y:ball.speedY}});
                    }
                }

                handleBallBrickCollision(ball, isPlayerOriginBalls);

                if (ball.x + ball.speedX > canvas.width - BALL_RADIUS || ball.x + ball.speedX < BALL_RADIUS) {
                    const wallHitSide = ball.x + ball.speedX > canvas.width - BALL_RADIUS ? 'right' : 'left';
                    ball.speedX = -ball.speedX;
                    logGameData("Side Wall Hit", { 
                        ballOwner: (isPlayerOriginBalls ? 'Player' : 'AI'), 
                        ballState: oldBallState, 
                        newBallSpeed: {x: ball.speedX, y: ball.speedY},
                        wall: wallHitSide
                    });
                }

                const ownPaddleX = isPlayerOriginBalls ? playerPaddleX : aiPaddleX;
                const ownPaddleY = isPlayerOriginBalls ? PLAYER_PADDLE_Y : AI_PADDLE_Y;
                const opponentPaddleX = isPlayerOriginBalls ? aiPaddleX : playerPaddleX;
                const opponentPaddleY = isPlayerOriginBalls ? AI_PADDLE_Y : PLAYER_PADDLE_Y;
                
                const ownPaddleTop = ownPaddleY;
                const ownPaddleCatchMinY = ownPaddleY + (isPlayerOriginBalls ? PADDLE_ARM_HEIGHT_EXTENDED : PADDLE_BASE_HEIGHT); // AI catch spot is on top of its base
                const ownPaddleCatchMaxY = ownPaddleY + (isPlayerOriginBalls ? PADDLE_TOTAL_HEIGHT : PADDLE_TOTAL_HEIGHT - PADDLE_ARM_HEIGHT_EXTENDED); // AI catch spot is on top of its base
                const ownPaddleHittingSurfaceY = isPlayerOriginBalls ? ownPaddleTop : ownPaddleY + PADDLE_TOTAL_HEIGHT;


                // Own paddle collision & Catch Logic
                if ((isPlayerOriginBalls && ball.speedY > 0 && ball.y + BALL_RADIUS >= ownPaddleTop && ball.y - BALL_RADIUS < ownPaddleTop + PADDLE_TOTAL_HEIGHT) ||
                    (!isPlayerOriginBalls && ball.speedY < 0 && ball.y - BALL_RADIUS <= ownPaddleY + PADDLE_TOTAL_HEIGHT && ball.y + BALL_RADIUS > ownPaddleY)) {
                    
                    if (ball.x > ownPaddleX && ball.x < ownPaddleX + PADDLE_WIDTH) { 
                        const paddleCenterX = ownPaddleX + PADDLE_WIDTH / 2;
                        const isWithinCatchSpotX = ball.x >= ownPaddleX + PADDLE_ARM_WIDTH_ORIGINAL && ball.x <= ownPaddleX + PADDLE_WIDTH - PADDLE_ARM_WIDTH_ORIGINAL;
                        
                        let wantsToCatch = isPlayerOriginBalls ? playerWantsToCatch : aiWantsToCatch;
                        let heldBallRef = isPlayerOriginBalls ? playerHeldBall : aiHeldBall;
                        let contactMade = false;
                        let ballCaughtThisTick = false;

                        // Catch condition check: Ball must be within the U-shaped base area
                        let verticalCatchConditionMet = false;
                        if (isPlayerOriginBalls) { // Player paddle (U opens up)
                            verticalCatchConditionMet = ball.y + BALL_RADIUS >= ownPaddleY + PADDLE_ARM_HEIGHT_EXTENDED && ball.y - BALL_RADIUS <= ownPaddleY + PADDLE_TOTAL_HEIGHT;
                        } else { // AI paddle (U opens down)
                            verticalCatchConditionMet = ball.y - BALL_RADIUS <= ownPaddleY + PADDLE_BASE_HEIGHT && ball.y + BALL_RADIUS >= ownPaddleY;
                        }
                           
                        if (wantsToCatch && isWithinCatchSpotX && verticalCatchConditionMet && !heldBallRef && Math.abs(ball.speedY) < BASE_BALL_SPEED_MAGNITUDE * 1.5) {
                            const caughtBall = ballArray.splice(i, 1)[0];
                            if (isPlayerOriginBalls) {
                                playerHeldBall = caughtBall;
                                logGameData("Player Caught Ball", {ballState: oldBallState, paddleX: playerPaddleX});
                                playerWantsToCatch = false; // Consume catch intent
                            } else {
                                aiHeldBall = caughtBall;
                                aiShootTimer = AI_SHOOT_DELAY_FRAMES; 
                                logGameData("AI Caught Ball", {ballState: oldBallState, paddleX: aiPaddleX});
                                aiWantsToCatch = false;
                            }
                            contactMade = true;
                            ballCaughtThisTick = true;
                        }

                        if (ballCaughtThisTick) continue; 

                        // Normal Bounce (if not caught)
                        // Determine if hit arms or base for logging/effects
                        let hitPart = "arm";
                        if (isWithinCatchSpotX) hitPart = "base";

                        // Collision detection for bounce
                        let bounceConditionMet = false;
                        if (isPlayerOriginBalls) { // Player paddle
                           if (ball.y + BALL_RADIUS >= ownPaddleY && ball.y - BALL_RADIUS < ownPaddleY + PADDLE_TOTAL_HEIGHT) bounceConditionMet = true;
                        } else { // AI paddle
                           if (ball.y - BALL_RADIUS <= ownPaddleY + PADDLE_TOTAL_HEIGHT && ball.y + BALL_RADIUS > ownPaddleY) bounceConditionMet = true;
                        }


                        if (bounceConditionMet) {
                            ball.speedY = -ball.speedY;
                            let deltaX = ball.x - (ownPaddleX + PADDLE_WIDTH / 2);
                            ball.speedX = deltaX * 0.22; 
                            ball.rallyHitCount = (ball.rallyHitCount || 0) + 1;
                            logGameData("Paddle Hit (Own)", { 
                                paddleOwner: (isPlayerOriginBalls ? 'Player' : 'AI'),
                                ballState: oldBallState,
                                newBallSpeed: {x: ball.speedX, y: ball.speedY},
                                paddleX: ownPaddleX, hitOffsetRatio: deltaX / (PADDLE_WIDTH/2),
                                hitPart: hitPart,
                                rallyCount: ball.rallyHitCount, ballSupercharged: ball.isSupercharged
                            });
                            if (ball.rallyHitCount >= RALLY_HIT_THRESHOLD_FOR_SPEEDUP && !ball.isBoosted && !ball.isSupercharged) {
                                ball.speedX = Math.min(MAX_BALL_SPEED_COMPONENT, Math.max(-MAX_BALL_SPEED_COMPONENT, ball.speedX * RALLY_SPEEDUP_FACTOR));
                                ball.speedY = Math.min(MAX_BALL_SPEED_COMPONENT, Math.max(-MAX_BALL_SPEED_COMPONENT, ball.speedY * RALLY_SPEEDUP_FACTOR));
                                logGameData("Rally Speed Up (Own Paddle)!", {ballOwner: (isPlayerOriginBalls ? 'Player' : 'AI'), newSpeed: {x: ball.speedX, y: ball.speedY}});
                                ball.rallyHitCount = 0; 
                            }
                             ball.isSupercharged = false; 
                        }
                    }
                }

                // Opponent paddle collision
                 if ((isPlayerOriginBalls && ball.speedY < 0 && ball.y - BALL_RADIUS <= opponentPaddleY + PADDLE_TOTAL_HEIGHT && ball.y + BALL_RADIUS > opponentPaddleY) ||
                    (!isPlayerOriginBalls && ball.speedY > 0 && ball.y + BALL_RADIUS >= opponentPaddleY && ball.y - BALL_RADIUS < opponentPaddleY + PADDLE_TOTAL_HEIGHT)) {
                     if (ball.x + BALL_RADIUS > opponentPaddleX && ball.x - BALL_RADIUS < opponentPaddleX + PADDLE_WIDTH) {
                        ball.speedY = -ball.speedY;
                        let deltaX = ball.x - (opponentPaddleX + PADDLE_WIDTH / 2);
                        ball.speedX = deltaX * 0.22; 
                        ball.rallyHitCount = (ball.rallyHitCount || 0) + 1;
                        ball.isSupercharged = false;
                         logGameData("Paddle Hit (Opponent's)", { 
                            hitByBallOwner: (isPlayerOriginBalls ? 'Player' : 'AI'),
                            opponentPaddleOwner: (isPlayerOriginBalls ? 'AI' : 'Player'),
                            ballState: oldBallState,
                            newBallSpeed: {x: ball.speedX, y: ball.speedY},
                            opponentPaddleX: opponentPaddleX, hitOffsetRatio: deltaX / (PADDLE_WIDTH/2),
                            rallyCount: ball.rallyHitCount, ballSupercharged: ball.isSupercharged
                        });
                         if (ball.rallyHitCount >= RALLY_HIT_THRESHOLD_FOR_SPEEDUP && !ball.isBoosted && !ball.isSupercharged) {
                            ball.speedX = Math.min(MAX_BALL_SPEED_COMPONENT, Math.max(-MAX_BALL_SPEED_COMPONENT, ball.speedX * RALLY_SPEEDUP_FACTOR));
                            ball.speedY = Math.min(MAX_BALL_SPEED_COMPONENT, Math.max(-MAX_BALL_SPEED_COMPONENT, ball.speedY * RALLY_SPEEDUP_FACTOR));
                            logGameData("Rally Speed Up (Opponent Paddle)!", {ballOwner: (isPlayerOriginBalls ? 'Player' : 'AI'), newSpeed: {x: ball.speedX, y: ball.speedY}});
                            ball.rallyHitCount = 0;
                        }
                    }
                }

                let scored = false;
                let goalPosition = {x: ball.x, y: ball.y}; 
                let pointsAwarded = 0;

                if (isPlayerOriginBalls) { 
                    if (ball.y + ball.speedY < BALL_RADIUS) { 
                        pointsAwarded = 1; playerScore += pointsAwarded; 
                        logGameData("Player scores GOAL! (W past AI - 1pt)", { playerScore, aiScore, ballFinalPos: goalPosition, ballState_pos: oldBallState.pos, ballState_speed: oldBallState.speed, ballState_supercharged: oldBallState.supercharged, ballState_boosted: oldBallState.boosted, ballState_rally: oldBallState.rallyHitCount, points: pointsAwarded });
                        ballArray.splice(i, 1); scored = true;
                    } else if (ball.y + ball.speedY > canvas.height - BALL_RADIUS) { 
                        pointsAwarded = 2; aiScore += pointsAwarded; 
                        logGameData("AI scores (Player W ball out own side - 2pts)!", { playerScore, aiScore, ballFinalPos: goalPosition, ballState_pos: oldBallState.pos, ballState_speed: oldBallState.speed, ballState_supercharged: oldBallState.supercharged, ballState_boosted: oldBallState.boosted, ballState_rally: oldBallState.rallyHitCount, points: pointsAwarded });
                        ballArray.splice(i, 1); scored = true;
                    }
                } else { 
                    if (ball.y + ball.speedY > canvas.height - BALL_RADIUS) { 
                        pointsAwarded = 1; aiScore += pointsAwarded; 
                        logGameData("AI scores GOAL! (Y past Player - 1pt)", { playerScore, aiScore, ballFinalPos: goalPosition, ballState_pos: oldBallState.pos, ballState_speed: oldBallState.speed, ballState_supercharged: oldBallState.supercharged, ballState_boosted: oldBallState.boosted, ballState_rally: oldBallState.rallyHitCount, points: pointsAwarded });
                        ballArray.splice(i, 1); scored = true;
                    } else if (ball.y + ball.speedY < BALL_RADIUS) { 
                        pointsAwarded = 2; playerScore += pointsAwarded; 
                        logGameData("Player scores (AI Y ball out own side - 2pts)!", { playerScore, aiScore, ballFinalPos: goalPosition, ballState_pos: oldBallState.pos, ballState_speed: oldBallState.speed, ballState_supercharged: oldBallState.supercharged, ballState_boosted: oldBallState.boosted, ballState_rally: oldBallState.rallyHitCount, points: pointsAwarded });
                        ballArray.splice(i, 1); scored = true;
                    }
                }
                
                if (!scored) { 
                    ball.x += ball.speedX;
                    ball.y += ball.speedY;
                } else { 
                    updateScoreDisplays(); 
                    logGameStateSnapshot("AfterScore");
                    if (checkWinCondition()) return;
                }
            }
            if (gameRunning && playerScore < WINNING_SCORE && aiScore < WINNING_SCORE) {
                if (isPlayerOriginBalls && playerBalls.length === 0 && !playerHeldBall) {
                    spawnNewBall('player', 'respawn_array_empty');
                } else if (!isPlayerOriginBalls && aiBalls.length === 0 && !aiHeldBall) {
                    spawnNewBall('ai', 'respawn_array_empty');
                }
            }
        }
        
        function handleBallToBallCollision() {
            if (playerBalls.length > 0 && aiBalls.length > 0) {
                const pBall = playerBalls[0]; 
                const aBall = aiBalls[0];

                if (pBall && aBall) { 
                    const dx = pBall.x - aBall.x;
                    const dy = pBall.y - aBall.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < BALL_RADIUS * 2) { 
                        let playerBallBroken = false;
                        let aiBallBroken = false;
                        let scorer = null;
                        let points = 0;

                        const pBallState = {pos:{x:pBall.x,y:pBall.y}, speed:{x:pBall.speedX, y:pBall.speedY}, supercharged:pBall.isSupercharged};
                        const aBallState = {pos:{x:aBall.x,y:aBall.y}, speed:{x:aBall.speedX, y:aBall.speedY}, supercharged:aBall.isSupercharged};

                        if (pBall.isSupercharged && !aBall.isSupercharged) {
                            logGameData("Player Supercharged Ball BROKE AI Ball", {pBallState, aBallState});
                            aiBalls.splice(0, 1); aiBallBroken = true;
                            points = 1; playerScore += points; scorer = 'Player';
                            pBall.isSupercharged = false; 
                        } else if (aBall.isSupercharged && !pBall.isSupercharged) {
                            logGameData("AI Supercharged Ball BROKE Player Ball", {aBallState, pBallState});
                            playerBalls.splice(0, 1); playerBallBroken = true;
                            points = 1; aiScore += points; scorer = 'AI';
                            aBall.isSupercharged = false; 
                        } else if (pBall.isSupercharged && aBall.isSupercharged) {
                            logGameData("MUTUAL Supercharged Ball Break!", {pBallState, aBallState});
                            playerBalls.splice(0, 1); aiBalls.splice(0, 1);
                            playerBallBroken = true; aiBallBroken = true;
                        } else { 
                            logGameData("Normal Ball-to-Ball Collision", {pBallState, aBallState});
                            const tempSpeedX = pBall.speedX; const tempSpeedY = pBall.speedY;
                            pBall.speedX = aBall.speedX; pBall.speedY = aBall.speedY;
                            aBall.speedX = tempSpeedX; aBall.speedY = tempSpeedY;
                            const overlap = (BALL_RADIUS * 2 - distance) / 2 + 0.1; 
                            pBall.x += (overlap * dx / distance); pBall.y += (overlap * dy / distance);
                            aBall.x -= (overlap * dx / distance); aBall.y -= (overlap * dy / distance);
                        }
                        
                        if (scorer) { logGameData(`${scorer} scores ${points}pt (Ball Break)`, { playerScore, aiScore }); }
                        updateScoreDisplays();
                        if (checkWinCondition()) return;

                        if (gameRunning && playerScore < WINNING_SCORE && aiScore < WINNING_SCORE) {
                            if (playerBallBroken && playerBalls.length === 0 && !playerHeldBall) {
                                spawnNewBall('player', 'respawn_ball_broken');
                            }
                            if (aiBallBroken && aiBalls.length === 0 && !aiHeldBall) {
                                spawnNewBall('ai', 'respawn_ball_broken');
                            }
                        }
                    }
                }
            }
        }

        // --- Game State Functions ---
        function updateScoreDisplays() {
            playerScoreDisplay.textContent = `Player: ${playerScore}`;
            aiScoreDisplay.textContent = `AI: ${aiScore}`;
        }
        
        function displayMessage(msg) {
            if (!gamePaused || msg.includes("PAUSED") || msg.includes("WINS") || msg.includes("GAME OVER")) {
                 messageArea.textContent = msg;
            } else if (gamePaused && messageArea.textContent !== "" && !messageArea.textContent.includes("PAUSED")){
            } else if (!gamePaused && messageArea.textContent.includes("PAUSED")) {
                 messageArea.textContent = ""; 
            }
        }

        function checkWinCondition() {
            if (!gameRunning) return false; 

            if (playerScore >= WINNING_SCORE) {
                displayMessage("PLAYER WINS!");
                gameOver('Player');
                return true;
            } else if (aiScore >= WINNING_SCORE) {
                displayMessage("AI WINS! GAME OVER!");
                gameOver('AI');
                return true;
            }
            return false;
        }
        
        function drawGameGraphics() { 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBricks();
            drawPaddle(playerPaddleX, PLAYER_PADDLE_Y, PLAYER_PADDLE_ARM_COLOR, PLAYER_PADDLE_CATCH_COLOR, PLAYER_PADDLE_CATCH_ACTIVE_COLOR, 'player', playerWantsToCatch); 
            drawPaddle(aiPaddleX, AI_PADDLE_Y, AI_PADDLE_ARM_COLOR, AI_PADDLE_CATCH_COLOR, AI_PADDLE_CATCH_ACTIVE_COLOR, 'ai', aiWantsToCatch);    
            
            playerBalls.forEach(ball => { ball.isPlayerOriginBall = true; drawBall(ball); });
            if(playerHeldBall) { playerHeldBall.isPlayerOriginBall = true; drawBall(playerHeldBall); }

            aiBalls.forEach(ball => { ball.isPlayerOriginBall = false; drawBall(ball); });
            if(aiHeldBall) { aiHeldBall.isPlayerOriginBall = false; drawBall(aiHeldBall); }
        }

        function gameLoop() {
            if (!gameRunning) {
                // logGameData("GameLoop called but game not running. Exiting loop."); // Avoid excessive logging if already stopped
                return; 
            }
            if (gamePaused) { 
                // logGameData("GameLoop called but game is paused. Drawing graphics only."); // Can be noisy
                drawGameGraphics(); 
                animationFrameId = requestAnimationFrame(gameLoop); 
                return; 
            }

            const currentTime = performance.now(); 
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            totalFramesRendered++;
            frameCountForDeltaLog++;
            if (frameCountForDeltaLog >= 120) { 
                logGameData("Frame Timing", { deltaTimeMs: deltaTime, totalFrames: totalFramesRendered, 
                    playerPaddle: {x: playerPaddleX, speed: currentPlayerPaddleMoveSpeed}, 
                    aiPaddle: {x: aiPaddleX, speed: currentAiPaddleMoveSpeed},
                    playerBallsCount: playerBalls.length + (playerHeldBall ? 1 : 0),
                    aiBallsCount: aiBalls.length + (aiHeldBall ? 1 : 0)
                });
                frameCountForDeltaLog = 0;
            }

            updatePlayerPaddle();
            updateAiPaddle();
            
            updateAndProcessBallArray(playerBalls, true);
            if (gameRunning) updateAndProcessBallArray(aiBalls, false); 
            
            if (gameRunning) handleBallToBallCollision(); 
            
            drawGameGraphics();
            
            if (gameRunning) { 
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                 logGameData("Game ended, stopping game loop animation frame.");
            }
        }
        
        function getActiveBrickData() {
            const activeBricks = [];
            for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
                for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                    if (bricks[c][r].status === 1) {
                        activeBricks.push({c: bricks[c][r].col, r: bricks[c][r].row, type: bricks[c][r].type, color: bricks[c][r].color});
                    }
                }
            }
            return activeBricks;
        }

        function logGameStateSnapshot(eventName) {
             const snapshotData = {
                event: eventName,
                timestamp: Date.now(),
                playerScore,
                aiScore,
                playerPaddle: { x: playerPaddleX, wantsCatch: playerWantsToCatch, isHolding: playerHeldBall !== null },
                aiPaddle: { x: aiPaddleX, wantsCatch: aiWantsToCatch, isHolding: aiHeldBall !== null },
                playerBallsActive: playerBalls.map(b => ({ pos: {x:b.x, y:b.y}, speed: {x:b.speedX, y:b.speedY}, super: b.isSupercharged, boost: b.isBoosted, rally:b.rallyHitCount })),
                aiBallsActive: aiBalls.map(b => ({ pos: {x:b.x, y:b.y}, speed: {x:b.speedX, y:b.speedY}, super: b.isSupercharged, boost: b.isBoosted, rally:b.rallyHitCount })),
                playerBallHeld: playerHeldBall ? { pos: {x:playerHeldBall.x, y:playerHeldBall.y} } : null,
                aiBallHeld: aiHeldBall ? { pos: {x:aiHeldBall.x, y:aiHeldBall.y} } : null,
                activeBricksCount: getActiveBrickData().length,
                activeBricksList: getActiveBrickData() // Log the list of active bricks
            };
            logGameData("GameStateSnapshot", snapshotData);
        }


        function resetGameVariables() {
            playerScore = 0;
            aiScore = 0;
            updateScoreDisplays();
            
            playerPaddleX = (canvas.width - PADDLE_WIDTH) / 2;
            aiPaddleX = (canvas.width - PADDLE_WIDTH) / 2;
            aiTargetX = aiPaddleX; 
            leftArrowPressed = false;
            rightArrowPressed = false;
            spacebarDown = false;
            playerWantsToCatch = false;
            playerHeldBall = null;
            aiWantsToCatch = false;
            aiHeldBall = null;
            aiShootTimer = 0;
            
            playerBalls = []; 
            aiBalls = [];   
            initBricks(); 
            if (gameLogHistory.length === 0 || (gameLogHistory.length > 0 && !gameLogHistory[gameLogHistory.length-1].includes("Game variables reset (initial)."))) { 
                 gameLogHistory = []; 
                 logGameData("Game variables reset for new game.", {version: GAME_VERSION});
            } else if (gameLogHistory.length === 0) { 
                 logGameData("Game variables reset (initial).", {version: GAME_VERSION});
            }
        }

        function startGame() {
            logGameData("Action: startGame() called.", { currentlyRunning: gameRunning, currentScoreP: playerScore, currentScoreAI: aiScore });
            gameStartTime = Date.now(); 
            lastFrameTime = performance.now(); 
            frameCountForDeltaLog = 0;
            totalFramesRendered = 0;
            
            if (gameRunning && animationFrameId) { 
                cancelAnimationFrame(animationFrameId);
                logGameData("Cancelled previous animation frame.");
            }
            resetGameVariables(); 
            
            spawnNewBall('player', 'initial_game_start'); 
            spawnNewBall('ai', 'initial_game_start');

            gameRunning = true; 
            gamePaused = false; 
            startButton.textContent = "Restart (R)";
            copyLogButton.textContent = 'Copy Log & Pause'; 
            logContainer.style.display = 'none'; 
            displayMessage("Arrows:Move, Space:Catch/Shoot, S:Pause, R:Start/Restart"); 
            logGameData("Game Started", { 
                version: GAME_VERSION,
                winningScore: WINNING_SCORE, 
                brickPattern: currentBrickPatternName,
                initialPlayerBalls: playerBalls.length + (playerHeldBall ? 1 : 0), 
                initialAiBalls: aiBalls.length + (aiHeldBall ? 1 : 0),
                playerPaddleX_start: playerPaddleX,
                aiPaddleX_start: aiPaddleX,
                timestamp: Date.now()
            });
            logGameStateSnapshot("GameStart");
            
            animationFrameId = requestAnimationFrame(gameLoop); 
        }

        function gameOver(winner) {
            const gameDurationMs = Date.now() - gameStartTime;
            const gameDurationSec = (gameDurationMs / 1000).toFixed(2);
            logGameData("Game Over", { 
                winner: winner, 
                playerScore, 
                aiScore, 
                finalPlayerBalls: playerBalls.length + (playerHeldBall ? 1:0), 
                finalAiBalls: aiBalls.length + (aiHeldBall ? 1:0),
                durationSeconds: parseFloat(gameDurationSec),
                totalFrames: totalFramesRendered,
                avgFps: parseFloat((totalFramesRendered / (Math.max(1, gameDurationMs) / 1000)).toFixed(2)),
                brickPattern: currentBrickPatternName,
                timestamp: Date.now()
            });
            logGameStateSnapshot("GameOver"); 
            gameRunning = false; 
            gamePaused = false; 
            startButton.textContent = "Play Again (R)";
            copyLogButton.textContent = 'Copy Final Log'; 
            if (logContainer.style.display !== 'none' || gameLogHistory.length > 0) { 
                gameLogOutput.value = gameLogHistory.join('\n');
                gameLogOutput.scrollTop = gameLogOutput.scrollHeight;
                logContainer.style.display = 'block'; 
            }
        }

        // Initial setup
        displayMessage("Arrows:Move, Space:Catch/Shoot, S:Pause, R:Start/Restart");
        calculateBrickOffsetTop(); 
        initBricks(); 
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBricks();
        drawPaddle(playerPaddleX, PLAYER_PADDLE_Y, PLAYER_PADDLE_ARM_COLOR, PLAYER_PADDLE_CATCH_COLOR, PLAYER_PADDLE_CATCH_ACTIVE_COLOR, 'player', playerWantsToCatch);
        drawPaddle(aiPaddleX, AI_PADDLE_Y, AI_PADDLE_ARM_COLOR, AI_PADDLE_CATCH_COLOR, AI_PADDLE_CATCH_ACTIVE_COLOR, 'ai', aiWantsToCatch);
        logGameData("Game Initialized (Static Display)", {version: GAME_VERSION, winningScore: WINNING_SCORE});
        
    </script>
</body>
</html>
