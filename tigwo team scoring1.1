<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TW triangle team scoring</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
        /* Style for number input arrows */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
          -webkit-appearance: none; 
          margin: 0; 
        }
        input[type=number] {
          -moz-appearance: textfield;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-white tracking-tight">TW triangle team scoring</h1>
            <p class="text-gray-400 mt-2">Live Score Tracker</p>
        </header>

        <!-- Scoreboard Section -->
        <div id="scoreboard" class="grid grid-cols-1 sm:grid-cols-3 gap-4 sm:gap-6 mb-8">
            <!-- Score cards will be dynamically inserted here -->
        </div>

        <!-- Match Results Table -->
        <div class="bg-gray-800 rounded-xl shadow-lg overflow-hidden">
            <div class="p-4 sm:p-6 border-b border-gray-700">
                <h2 class="text-xl font-semibold text-white">Match Results</h2>
                <p class="text-sm text-gray-400 mt-1">Update match outcomes below to see live score changes.</p>
            </div>
            <div class="overflow-x-auto">
                <table class="w-full text-sm text-left text-gray-300">
                    <thead class="text-xs text-gray-400 uppercase bg-gray-700/50">
                        <tr>
                            <th scope="col" class="px-4 py-3">Match</th>
                            <th scope="col" class="px-4 py-3">Competitors</th>
                            <th scope="col" class="px-4 py-3">Winner</th>
                            <th scope="col" class="px-4 py-3">Win Method</th>
                            <th scope="col" class="px-4 py-3">Time Left</th>
                            <th scope="col" class="px-4 py-3">Scores at Finish</th>
                            <th scope="col" class="px-4 py-3 text-right">Points</th>
                        </tr>
                    </thead>
                    <tbody id="matches-tbody">
                        <!-- Match rows will be dynamically inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Download Button Section -->
        <div class="text-center mt-8">
            <button id="download-report-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-300 shadow-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50">
                Download Report
            </button>
        </div>

        <footer class="text-center mt-6 text-gray-500 text-xs">
            <p>Scoreboard generated by Gemini. All rules implemented as specified.</p>
        </footer>
    </div>

    <script>
        // --- PERFORMANCE & DIAGNOSTICS ---
        const startTime = performance.now();
        let lastCalculationTime = 0;
        const SCORING_RULES_VERSION = "v3.1-dynamic-penalty";

        // --- DATA SETUP ---

        const TEAMS = { HAWKS: 'Hawks', PIGEONS: 'Pigeons', CROWS: 'Crows' };
        const GENDERS = { MALE: 'Male', FEMALE: 'Female' };
        const WEIGHT_CLASSES = {
            MALE: ['Cherry', 'Apple', 'Orange', 'Pineapple', 'Watermelon'],
            FEMALE: ['Cherry', 'Apple', 'Orange', 'Pineapple', 'Watermelon']
        };
        const WIN_METHODS = ['Submission', 'Pin', 'Shutout', 'Points', 'OT Submission', 'OT Pin', 'OT Win'];
        const PLAYERS = [
            // A list of all 30 players, structured as { name, team, gender }
            { name: 'Daigo Umehara', team: TEAMS.HAWKS, gender: GENDERS.MALE }, { name: 'Tokido', team: TEAMS.HAWKS, gender: GENDERS.MALE },
            { name: 'Punk', team: TEAMS.HAWKS, gender: GENDERS.MALE }, { name: 'MenaRD', team: TEAMS.HAWKS, gender: GENDERS.MALE },
            { name: 'Infiltration', team: TEAMS.HAWKS, gender: GENDERS.MALE }, { name: 'Cuddle_Core', team: TEAMS.HAWKS, gender: GENDERS.FEMALE },
            { name: 'Sherryjenix', team: TEAMS.HAWKS, gender: GENDERS.FEMALE }, { name: 'Ricki Ortiz', team: TEAMS.HAWKS, gender: GENDERS.FEMALE },
            { name: 'Lilo', team: TEAMS.HAWKS, gender: GENDERS.FEMALE }, { name: 'ChocoBlanka', team: TEAMS.HAWKS, gender: GENDERS.FEMALE },
            { name: 'Fuudo', team: TEAMS.PIGEONS, gender: GENDERS.MALE }, { name: 'Bonchan', team: TEAMS.PIGEONS, gender: GENDERS.MALE },
            { name: 'Luffy', team: TEAMS.PIGEONS, gender: GENDERS.MALE }, { name: 'Problem X', team: TEAMS.PIGEONS, gender: GENDERS.MALE },
            { name: 'Big Bird', team: TEAMS.PIGEONS, gender: GENDERS.MALE }, { name: 'A-RU', team: TEAMS.PIGEONS, gender: GENDERS.FEMALE },
            { name: 'MOV', team: TEAMS.PIGEONS, gender: GENDERS.FEMALE }, { name: 'Eita', team: TEAMS.PIGEONS, gender: GENDERS.FEMALE },
            { name: 'Fuumin', team: TEAMS.PIGEONS, gender: GENDERS.FEMALE }, { name: 'Itazan', team: TEAMS.PIGEONS, gender: GENDERS.FEMALE },
            { name: 'AngryBird', team: TEAMS.CROWS, gender: GENDERS.MALE }, { name: 'iDom', team: TEAMS.CROWS, gender: GENDERS.MALE },
            { name: 'Oil King', team: TEAMS.CROWS, gender: GENDERS.MALE }, { name: 'Gachikun', team: TEAMS.CROWS, gender: GENDERS.MALE },
            { name: 'Mago', team: TEAMS.CROWS, gender: GENDERS.MALE }, { name: 'NL', team: TEAMS.CROWS, gender: GENDERS.FEMALE },
            { name: 'Xiaohai', team: TEAMS.CROWS, gender: GENDERS.FEMALE }, { name: 'Poongko', team: TEAMS.CROWS, gender: GENDERS.FEMALE },
            { name: 'Go1', team: TEAMS.CROWS, gender: GENDERS.FEMALE }, { name: 'Dogura', team: TEAMS.CROWS, gender: GENDERS.FEMALE },
        ];

        let matchData = [];
        let teamScores = { [TEAMS.HAWKS]: 0, [TEAMS.PIGEONS]: 0, [TEAMS.CROWS]: 0 };

        // --- CORE LOGIC (FINALIZED) ---

        /**
         * Calculates points for a single match based on the final, dynamic scoring system.
         * This function contains the complete and most up-to-date scoring rules.
         * @param {object} match - The match object containing all result data.
         * @returns {{winnerPoints: number, loserPoints: number}} - The calculated points for winner and loser.
         */
        function calculateMatchPoints(match) {
            let winnerPoints = 0;
            let loserPoints = 0;
            const { winMethod, timeLeft, winnerScoreAtFinish, loserScoreAtFinish } = match;

            // 1. Calculate Winner's Base Score
            let baseScore = 0;
            switch (winMethod) {
                case 'Submission': baseScore = (timeLeft * 2.6) + 32; break;
                case 'Pin': baseScore = (timeLeft * 1.8) + 15; break;
                case 'Shutout': baseScore = (timeLeft * 1.4) + 10; break;
                case 'Points': baseScore = (timeLeft * 1.2) + 6; break;
                case 'OT Submission': baseScore = 11; break;
                case 'OT Pin': baseScore = 5; break;
                case 'OT Win': baseScore = -2; break;
            }

            // 2. Apply Flawless Victory Bonus if applicable (only for regulation wins)
            if (loserScoreAtFinish === 0 && ['Pin', 'Submission', 'Shutout', 'Points'].includes(winMethod)) {
                 winnerPoints = (baseScore * 1.05) + 10;
            } else {
                winnerPoints = baseScore;
            }

            // 3. Calculate Loser's Penalty (Dynamic for finishes)
            switch (winMethod) {
                case 'Submission':
                    const subDifferential = loserScoreAtFinish - winnerScoreAtFinish;
                    // Penalty is -12, but reduced by the loser's point advantage. Cannot become positive.
                    loserPoints = Math.min(0, -12 + subDifferential);
                    break;
                case 'Pin':
                    const pinDifferential = loserScoreAtFinish - winnerScoreAtFinish;
                    // Penalty is -10, but reduced by the loser's point advantage. Cannot become positive.
                    loserPoints = Math.min(0, -10 + pinDifferential);
                    break;
                case 'Shutout': loserPoints = -5; break;
                case 'Points': loserPoints = -4; break;
                case 'OT Submission': loserPoints = -11; break; // New flat penalty
                case 'OT Pin': loserPoints = -9; break; // Stacked penalty: -3 (OT loss) + -6 (pin loss)
                case 'OT Win': loserPoints = -3; break;
            }
            
            return { winnerPoints, loserPoints };
        }

        /**
         * Recalculates all team scores from scratch based on the current state of matchData.
         * This is the main calculation engine of the scoreboard.
         */
        function calculateAllScores() {
            const calcStart = performance.now();
            teamScores = { [TEAMS.HAWKS]: 0, [TEAMS.PIGEONS]: 0, [TEAMS.CROWS]: 0 };
            
            matchData.forEach(match => {
                if (match.winner) {
                    const { winnerPoints, loserPoints } = calculateMatchPoints(match);
                    const winnerTeam = match.winner.team;
                    const loserTeam = match.p1.name === match.winner.name ? match.p2.team : match.p1.team;
                    
                    teamScores[winnerTeam] += winnerPoints;
                    teamScores[loserTeam] += loserPoints;
                    match.points = winnerPoints; // Store for display
                } else {
                    match.points = 0;
                }
            });

            renderScores();
            updateTablePoints();
            lastCalculationTime = performance.now() - calcStart; // Log calculation time
        }

        /**
         * Handles user input changes from the table and triggers a score recalculation.
         * @param {number} matchId - The ID of the match being updated.
         */
        function handleResultChange(matchId) {
            const match = matchData.find(m => m.id === matchId);
            if (!match) return;

            // Grab all relevant input elements from the DOM
            const winnerSelect = document.getElementById(`winner-${matchId}`);
            const methodSelect = document.getElementById(`method-${matchId}`);
            const timeInput = document.getElementById(`time-${matchId}`);
            const winnerScoreInput = document.getElementById(`winner-score-${matchId}`);
            const loserScoreInput = document.getElementById(`loser-score-${matchId}`);

            // Update the central matchData object with the new values
            const selectedWinnerName = winnerSelect.value;
            match.winner = selectedWinnerName ? PLAYERS.find(p => p.name === selectedWinnerName) : null;
            match.winMethod = methodSelect.value;
            match.timeLeft = parseInt(timeInput.value, 10) || 0;
            match.winnerScoreAtFinish = parseInt(winnerScoreInput.value, 10) || 0;
            match.loserScoreAtFinish = parseInt(loserScoreInput.value, 10) || 0;

            // --- UI Logic ---
            // Disable time input for Overtime matches
            const isOvertime = match.winMethod.startsWith('OT');
            timeInput.disabled = isOvertime;
            if (isOvertime) {
                timeInput.value = 0;
                match.timeLeft = 0;
            }

            // Disable score inputs unless the win method requires them for dynamic penalties
            const needsScores = match.winMethod === 'Pin' || match.winMethod === 'Submission';
            winnerScoreInput.disabled = !needsScores;
            loserScoreInput.disabled = !needsScores;
            if (!needsScores) {
                winnerScoreInput.value = 0;
                loserScoreInput.value = 0;
                match.winnerScoreAtFinish = 0;
                match.loserScoreAtFinish = 0;
            }

            // Trigger the global score recalculation
            calculateAllScores();
        }

        // --- RENDERING LOGIC ---

        /** Renders the top scoreboard cards. */
        function renderScores() {
            const scoreboardDiv = document.getElementById('scoreboard');
            const teamColors = {
                [TEAMS.HAWKS]: 'bg-red-700/50 border-red-500',
                [TEAMS.PIGEONS]: 'bg-blue-700/50 border-blue-500',
                [TEAMS.CROWS]: 'bg-purple-700/50 border-purple-500'
            };
            scoreboardDiv.innerHTML = Object.entries(teamScores).map(([team, score]) => `
                <div class="p-5 rounded-lg shadow-md border ${teamColors[team]}">
                    <h3 class="text-lg font-semibold text-gray-300">${team}</h3>
                    <p class="text-3xl font-bold text-white mt-2">${score.toFixed(2)}</p>
                </div>
            `).join('');
        }

        /** Renders the main table of matches. */
        function renderMatchTable() {
            const tbody = document.getElementById('matches-tbody');
            tbody.innerHTML = matchData.map(match => {
                const isOvertime = match.winMethod.startsWith('OT');
                const needsScores = match.winMethod === 'Pin' || match.winMethod === 'Submission';
                return `
                <tr id="row-${match.id}" class="bg-gray-800 border-b border-gray-700 hover:bg-gray-700/50 transition-colors duration-200">
                    <td class="px-4 py-3 font-medium text-gray-200">${match.id}</td>
                    <td class="px-4 py-3">
                        <div>${match.p1.name} <span class="text-xs text-red-400">(${match.p1.team})</span></div>
                        <div class="text-gray-400">vs</div>
                        <div>${match.p2.name} <span class="text-xs text-blue-400">(${match.p2.team})</span></div>
                    </td>
                    <td class="px-4 py-3">
                        <select id="winner-${match.id}" onchange="handleResultChange(${match.id})" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2">
                            <option value="">-- Select --</option>
                            <option value="${match.p1.name}" ${match.winner && match.winner.name === match.p1.name ? 'selected' : ''}>${match.p1.name}</option>
                            <option value="${match.p2.name}" ${match.winner && match.winner.name === match.p2.name ? 'selected' : ''}>${match.p2.name}</option>
                        </select>
                    </td>
                    <td class="px-4 py-3">
                        <select id="method-${match.id}" onchange="handleResultChange(${match.id})" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2">
                            ${WIN_METHODS.map(m => `<option value="${m}" ${match.winMethod === m ? 'selected' : ''}>${m}</option>`).join('')}
                        </select>
                    </td>
                    <td class="px-4 py-3">
                        <input type="number" id="time-${match.id}" value="${match.timeLeft}" oninput="handleResultChange(${match.id})" min="0" max="360" ${isOvertime ? 'disabled' : ''} class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg w-20 p-2 disabled:opacity-50">
                    </td>
                    <td class="px-4 py-3">
                        <div class="flex items-center space-x-2">
                            <input type="number" id="winner-score-${match.id}" value="${match.winnerScoreAtFinish}" oninput="handleResultChange(${match.id})" min="0" ${!needsScores ? 'disabled' : ''} class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg w-16 p-2 disabled:opacity-50" placeholder="W">
                            <span class="text-gray-500">-</span>
                            <input type="number" id="loser-score-${match.id}" value="${match.loserScoreAtFinish}" oninput="handleResultChange(${match.id})" min="0" ${!needsScores ? 'disabled' : ''} class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg w-16 p-2 disabled:opacity-50" placeholder="L">
                        </div>
                    </td>
                    <td id="points-${match.id}" class="px-4 py-3 text-right font-semibold text-green-400">${match.points.toFixed(2)}</td>
                </tr>
            `}).join('');
        }
        
        /** Efficiently updates only the points column without redrawing the whole table. */
        function updateTablePoints() {
            matchData.forEach(match => {
                const pointsCell = document.getElementById(`points-${match.id}`);
                if (pointsCell) pointsCell.textContent = match.points.toFixed(2);
            });
        }

        /**
         * Gathers all data and enhanced diagnostic info, then triggers a download.
         */
        function generateReport() {
            // 1. Gather Enhanced Diagnostic Info
            const diagnostics = `
--- DIAGNOSTIC INFORMATION ---
Report Generated: ${new Date().toLocaleString()}
Scoring Rules Version: ${SCORING_RULES_VERSION}
User Agent: ${navigator.userAgent}
Viewport: ${window.innerWidth}px x ${window.innerHeight}px
App Status: Initialized Successfully

--- PERFORMANCE ---
Initial Load Time: ${(performance.now() - startTime).toFixed(2)} ms
Last Score Calculation: ${lastCalculationTime.toFixed(2)} ms
`;

            // 2. Gather Win Type Summary
            const winCounts = matchData.reduce((acc, match) => {
                if (match.winner) {
                    acc[match.winMethod] = (acc[match.winMethod] || 0) + 1;
                }
                return acc;
            }, {});
            const winSummary = `
--- TOURNAMENT SUMMARY ---
${Object.entries(winCounts).map(([method, count]) => `${method}: ${count}`).join('\n')}
`;

            // 3. Gather Team Scores
            const scores = `
--- FINAL TEAM SCORES ---
${Object.entries(teamScores).map(([team, score]) => `${team}: ${score.toFixed(2)}`).join('\n')}
`;

            // 4. Gather Detailed Match Data (CSV format)
            let matchCsv = 'Match ID,P1,P1 Team,P2,P2 Team,Winner,Win Method,Time Left,Winner Score,Loser Score,Points Awarded\n';
            matchData.forEach(match => {
                const winnerName = match.winner ? match.winner.name : 'N/A';
                const row = [
                    match.id, `"${match.p1.name}"`, match.p1.team, `"${match.p2.name}"`, match.p2.team,
                    `"${winnerName}"`, match.winMethod, match.timeLeft, match.winnerScoreAtFinish, match.loserScoreAtFinish,
                    match.points.toFixed(2)
                ].join(',');
                matchCsv += row + '\n';
            });
            const matchReport = `
--- DETAILED MATCH RESULTS (CSV) ---
${matchCsv}
`;

            // 5. Combine and Download
            const fullReport = `TW TRIANGLE TEAM SCORING REPORT\n=================================\n${diagnostics}\n${winSummary}\n${scores}\n${matchReport}`;
            const blob = new Blob([fullReport], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'tw_tournament_report.txt';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- INITIALIZATION & SIMULATION ---

        /** Generates the full schedule of 30 matches. */
        function createSchedule() {
            const matchups = [[TEAMS.HAWKS, TEAMS.PIGEONS], [TEAMS.HAWKS, TEAMS.CROWS], [TEAMS.PIGEONS, TEAMS.CROWS]];
            let id = 1;
            matchups.forEach(([teamA, teamB]) => {
                [GENDERS.MALE, GENDERS.FEMALE].forEach(gender => {
                    const playersA = PLAYERS.filter(p => p.team === teamA && p.gender === gender);
                    const playersB = PLAYERS.filter(p => p.team === teamB && p.gender === gender);
                    for (let i = 0; i < 5; i++) {
                        matchData.push({
                            id: id++, p1: playersA[i], p2: playersB[i], gender: gender,
                            weightClass: gender === GENDERS.MALE ? WEIGHT_CLASSES.MALE[i] : WEIGHT_CLASSES.FEMALE[i],
                            winner: null, winMethod: 'Points', timeLeft: 0, points: 0,
                            winnerScoreAtFinish: 0, loserScoreAtFinish: 0
                        });
                    }
                });
            });
        }
        
        /** Simulates random results for all matches to demonstrate functionality. */
        function simulateResults() {
            matchData.forEach(match => {
                match.winner = Math.random() < 0.5 ? match.p1 : match.p2;
                match.winMethod = WIN_METHODS[Math.floor(Math.random() * WIN_METHODS.length)];
                if (match.winMethod.startsWith('OT')) {
                    match.timeLeft = 0;
                } else {
                    match.timeLeft = Math.floor(Math.pow(Math.random(), 2) * 360);
                    if (match.winMethod === 'Pin' || match.winMethod === 'Submission') {
                        match.winnerScoreAtFinish = Math.floor(Math.random() * 10);
                        match.loserScoreAtFinish = Math.floor(Math.random() * 10);
                    }
                }
            });
        }

        /** Initializes the application on page load. */
        function initialize() {
            createSchedule();
            simulateResults();
            renderMatchTable();
            calculateAllScores();
            document.getElementById('download-report-btn').addEventListener('click', generateReport);
        }

        // Run the app when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>

